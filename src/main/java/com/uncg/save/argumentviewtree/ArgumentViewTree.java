/*
===========================================================================
                        Software Engineering Ethics Debater (SWED) Source Code
                           Copyright (C) 2019 Nancy Green

Software Engineering Ethics Debater (SWED) is free software: you can redistribute it and/or 
modify it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

SWED Source Code is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with SWED Source Code.  If not, see <http://www.gnu.org/licenses/>.

If you have questions concerning this license or the applicable additional 
terms, you may contact Dr. Nancy Green at the University of North
Carolina at Greensboro.
        
===========================================================================
*/

package com.uncg.save.argumentviewtree;

import static com.uncg.save.argumentviewtree.ArgumentNode.MULTI_ARG_Y_OFFSET;
import static com.uncg.save.argumentviewtree.ArgumentNode.PADDING;
import static com.uncg.save.argumentviewtree.ArgumentNode.PREMISE_HEIGHT;
import static com.uncg.save.argumentviewtree.ArgumentNode.PREMISE_WIDTH;
import com.uncg.save.controllers.ArgumentCertaintyPaneController;
import com.uncg.save.controllers.CQArgumentPaneController;
import com.uncg.save.controllers.CQPaneController;
import com.uncg.save.controllers.ChainPaneController;
import com.uncg.save.controllers.ChainPropositionChoice;
import com.uncg.save.controllers.ChainTwoPropWarningPaneController;
import com.uncg.save.controllers.ConclusionPaneController;
import com.uncg.save.controllers.ConstructionAreaController;
import com.uncg.save.controllers.CounterArgumentPaneController;
import com.uncg.save.controllers.CounterPropositionPaneController;
import com.uncg.save.controllers.MultiArgChainPaneController;
import com.uncg.save.controllers.MultiArgConclusionPaneController;
import com.uncg.save.controllers.MultiArgSubConclusionPaneController;
import com.uncg.save.controllers.PremisePaneController;
import com.uncg.save.models.ArgumentModel;
import com.uncg.save.models.CQTuple;
import com.uncg.save.models.CounterArgumentModel;
import com.uncg.save.models.PremiseModel;
import com.uncg.save.util.AlertStage;
import com.uncg.save.util.FXUtils;
import com.uncg.save.util.LayoutUtils;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Queue;
import java.util.Set;
import java.util.Stack;
import java.util.logging.Level;
import java.util.logging.Logger;
import javafx.fxml.FXMLLoader;
import javafx.geometry.Bounds;
import javafx.geometry.Point2D;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Alert.AlertType;
import javafx.scene.control.Label;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Line;
import javafx.scene.text.Font;
import javafx.stage.Modality;
import javafx.stage.Stage;

/**
 * ArgumentViewTree class provides an entrance to an argument view tree via
 * root. It also defines methods used in the construction, deletion, and
 * alteration of argument view trees.
 *
 * Edit 05/17/19: I made this class Serializable in an attempt to write it to a
 * file. Needless to say, it didn't work too well.
 *
 * TODO: this class needs major refactoring to remove repeated code and make the
 * class more focused
 *
 *
 */
public class ArgumentViewTree
{
    //
    // unique string id. Generated by getting string representation of
    // getHash() method of this tree object
    //
    private   String                         treeID                 = null;
    private   int                            size                   = -1;    //Size of tree
    private   boolean                        minimizeTree           = false;    
    private   int                            activeCQs              = 0;

    //
    //  Root node of an argument view tree
    //
    private   ConclusionNode                 root                   = null;

    //
    // collison matrices used to detect collision between view elements
    //
    protected List<List<ArgumentNode>>       paneMatrix             = null;
    protected List<List<ArgumentNode>>       nexusMatrix            = null;
    
    //
    // This list holds all premise connection nodes in the tree;
    // used for later re-positioning all end-points
    //
    protected List<PremiseConnectionNode>    premiseConnectionNodes = null;
    
    //
    // Pane that represents the constructionArea that this tree will be drawn on
    //
    private final Pane                       canvas;
    private final ConstructionAreaController canvasControl;

    /**
     * Constructs new ArgumentViewTree and associates it with a specific pane
     * that will contain it. Starts with a null root.
     *
     * @param pane Pane
     */
    public ArgumentViewTree( Pane pane, ConstructionAreaController control )
    {
        this.canvas                 = pane;
        this.canvasControl          = control;
        this.root                   = null;
        this.paneMatrix             = new LinkedList<>();
        this.nexusMatrix            = new LinkedList<>();
        this.premiseConnectionNodes = new LinkedList<>();
    }

    /*
     * Getters/setters
     */
    public ConclusionNode getRoot()
    {
        return root;
    }

    public String getTreeID()
    {
        return treeID;
    }

    public void setTreeID( String id )
    {
        treeID = id;
    }

    public List<List<ArgumentNode>> getPaneMatrix()
    {
        return this.paneMatrix;
    }

    public List<List<ArgumentNode>> getNexusMatrix()
    {
        return this.nexusMatrix;
    }

    /**
     * Adds a new root argument to a tree. This should be called when a new
     * argument is to be generated from a scheme.
     *
     * @param argument ArgumentModel. Backing model for the root argument
     * @param x double. X coordinate value specifying where the tree will be
     * generated.
     * @param y double. Y coordinate value specifying where the tree will be
     * generated.
     */
    public void addRootArgument( ArgumentModel argument, int x, int y )
    {
        this.premiseConnectionNodes = new LinkedList<>();
        
        try
        {
            Point2D localCoords = LayoutUtils.getLocalCoords( canvas, x, y );
            root = createConclusionView( argument, localCoords );
            canvas.getChildren().add( root.getView() );
            List<ArgumentNode> rootPaneList = new ArrayList<>();
            rootPaneList.add( root );
            paneMatrix.add( rootPaneList );

            ArgumentNode certaintyBox = createArgumentCertaintyBox( argument.getConclusion(), root );
            root.addAsChild( certaintyBox );
            certaintyBox.setParent( root );
            canvas.getChildren().add( certaintyBox.getView() );

            ArgumentNode connector = createConclusionConnector( root.getView() );
            root.addAsChild( connector );
            connector.setParent( root );
            canvas.getChildren().add( connector.getView() );

            ArgumentNode schemeLabel = createSchemeLabel( argument, root.getView() );
            root.addAsChild( schemeLabel );
            schemeLabel.setParent( root );
            canvas.getChildren().add( schemeLabel.getView() );

            ArgumentNode nexus = createNexus( argument.getSchemeNumPremises(), connector.getView() );
            connector.addAsChild( nexus );
            nexus.setParent( connector );
            canvas.getChildren().add( nexus.getView() );
            List<ArgumentNode> rootNexusList = new ArrayList<>();
            rootNexusList.add( nexus );
            nexusMatrix.add( rootNexusList );
            
            nexus.getView().setVisible( false );

            int numPremises = argument.getSchemeNumPremises();
            List<ArgumentNode> premiseNodes = new ArrayList<>();
            
            for ( int i = 0; i < numPremises; i ++ )
            {
                ArgumentNode premiseConnect = createPremiseConnection( connector.getView(), i );
                nexus.addAsChild( premiseConnect );
                premiseConnect.setParent( nexus );
                canvas.getChildren().add( premiseConnect.getView() );
                premiseConnect.getView().toBack();
                this.premiseConnectionNodes.add( ( PremiseConnectionNode ) premiseConnect );

                ArgumentNode premiseBox = createPremiseView( argument, premiseConnect.getView(), i );
                ArgumentNode certaintyBoxP = createArgumentCertaintyBox( argument, ( PremiseNode ) premiseBox );
                premiseBox.addAsChild( certaintyBoxP );
                certaintyBoxP.setParent( premiseBox );
                canvas.getChildren().add( certaintyBoxP.getView() );
                premiseConnect.addAsChild( premiseBox );
                premiseBox.setParent( premiseConnect );
                canvas.getChildren().add( premiseBox.getView() );

                premiseNodes.add( premiseBox );
            }
            paneMatrix.add( premiseNodes );
            root.getControl().initializePane();
        } 
        catch ( IOException ex )
        {
            Logger.getLogger( ArgumentViewTree.class.getName() ).log( Level.SEVERE, null, ex );
        }
    }

    /**
     * Creates a new conclusion pane to be drawn on the tree
     *
     * @param arg ArgumentModel. Backing model for argument
     * @param x double. X coordinate value specifying where the tree will be
     * generated.
     * @param y double. Y coordinate value specifying where the tree will be
     * generated.
     *
     * @return ArgumentNode to be added to tree structure
     *
     * @throws IOException in case of FXML loading failure
     */
    private ConclusionNode createConclusionView( ArgumentModel arg, Point2D localCoords ) throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass().getResource( "/fxml/ConclusionPane.fxml" ) );
        Pane conclusionPane = loader.load();
        ConclusionPaneController conclusionControl = loader.<ConclusionPaneController>getController();
        conclusionControl.addConclusionArgumentModel( arg );
        conclusionControl.setArgumentViewTree( this );
        conclusionControl.setParentControl( canvasControl );
        Label lbl = createLabel();
        lbl.setText( arg.getSchemeConclusion() );
        conclusionControl.setSchemeLabel( lbl );
        LayoutUtils.setChildLayout( conclusionPane, localCoords );

        return new ConclusionNode( conclusionPane, conclusionControl );
    }

    private ArgumentNode createArgumentCertaintyBox( PremiseModel controllingModel, ConclusionNode parent ) throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass().getResource( "/fxml/ArgumentCertaintyPane.fxml" ) );
        Pane certPane = loader.load();
        ArgumentCertaintyPaneController certControl = loader.<ArgumentCertaintyPaneController>getController();
        parent.getControl().setCertaintyController( certControl );

        canvas.layout();
        Bounds bounds = parent.getView().getBoundsInParent();
        Point2D targetCoords = new Point2D( bounds.getMinX() + 50, bounds.getMaxY() );
        certControl.setControllingModel( controllingModel );
        return new ArgumentCertaintyNode( certPane, certControl, targetCoords );
    }

    private ArgumentNode createArgumentCertaintyBox( ArgumentModel argument, PremiseNode parent ) throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass().getResource( "/fxml/ArgumentCertaintyPane.fxml" ) );
        Pane certPane = loader.load();
        ArgumentCertaintyPaneController certControl = loader.<ArgumentCertaintyPaneController>getController();
        parent.getControl().setCertaintyController( certControl );

        canvas.layout();
        Bounds bounds = parent.getView().getBoundsInParent();
        Point2D targetCoords = new Point2D( bounds.getMinX() + 50, bounds.getMaxY() );
        certControl.setControllingModel( argument.getConclusion() );
        return new ArgumentCertaintyNode( certPane, certControl, targetCoords );
    }

    /**
     * Creates a new Node that connects the conclusion pane to the premise
     * structure. Its layout is determine in relation to the layout of its
     * parent view
     *
     * @param parentView Node. Parent conclusion pane of this connector
     *
     * @return ArgumentNode to be added to the tree structure
     */
    private ArgumentNode createConclusionConnector( Node parentView )
    {
        Point2D layout = getRelativeLayout( parentView );
        ConclusionConnectionNode connector = new ConclusionConnectionNode( layout );

        return connector;
    }

    private ArgumentNode createSchemeLabel( ArgumentModel argument, Node parentView )
    {
        Point2D layout = getRelativeLayout( parentView );
        ArgumentNode schemeLabel = new ArgumentSchemeLabel( argument, layout, this, canvas );

        return schemeLabel;
    }

    /**
     * Creates a "premise nexus" the horizontal line that graphically joins all
     * of the premises in an argument in the argument view tree
     *
     * @param arg ArgumentModel. Backing model for the argument associated with
     * this part of the tree
     * @param parentView Node. Parent JavaFX node of this node.
     *
     * @return ArgumentNode to be added to the tree structure
     */
    private ArgumentNode createNexus( int numPremises, Node parentView )
    {
        Point2D layout         = getRelativeLayout( parentView );
        PremiseNexusNode nexus = new PremiseNexusNode( numPremises, layout );

        return nexus;
    }
    
    private ArgumentNode createMultiArgPremiseNexus( int numPremises, Node parentView )
    {
        Point2D layout                 = getRelativeLayout( parentView );
        MultiArgPremiseNexusNode nexus = new MultiArgPremiseNexusNode( numPremises, layout );

        return nexus;
    }

    private ArgumentNode createPremiseConnection( Node parentView, int premiseNumber, boolean argument )
    {
        Point2D layout         = getRelativeLayout( parentView );      
        Point2D adjustedLayout = null;
        
        if ( argument )
        {
            adjustedLayout = new Point2D( layout.getX() - ( parentView.getBoundsInParent().getWidth() ),
                                          layout.getY() );
        }
        else 
        {
            adjustedLayout = new Point2D( layout.getX() - 55, layout.getY() - 4 );            
        }

        PremiseConnectionNode premiseConnection = new PremiseConnectionNode( adjustedLayout, argument );

        return premiseConnection;
    }
    
    /**
     * Creates the vertical lines that connect premise views to the premise
     * nexus. Their position is determined relative to their parent premise
     * nexus and are also offset according to which premise number they are\
     * associated with.
     *
     * @param parentView Node. JavaFX parent of this view structure. Should be a
     * view contained in a PremiseNexus
     * @param premiseNumber int. Number representing the premise position.
     *
     * @return ArgumentNode meant to be added to the tree structure
     */    
    private ArgumentNode createPremiseConnection( Node parentView, int premiseNumber )
    {
        Point2D layout         = getRelativeLayout( parentView );
        Point2D adjustedLayout = new Point2D( layout.getX() ,
                                              layout.getY());
        
        PremiseConnectionNode premiseConnection = new PremiseConnectionNode( premiseNumber, adjustedLayout );

        return premiseConnection;
    }    
    
    private ArgumentNode createCQPremiseConnection( Node parentView )
    {
        Point2D layout         = getRelativeLayout( parentView );
        Point2D adjustedLayout = new Point2D( layout.getX() ,
                                              layout.getY() - PREMISE_HEIGHT / 2 );
        
        PremiseConnectionNode premiseConnection = new PremiseConnectionNode( adjustedLayout, ++this.activeCQs );

        return premiseConnection;
    }        

    private ArgumentNode createMultiArgPremiseConnection( Node parentView, int premiseNumber )
    {
        Point2D layout         = getRelativeLayout( parentView );
        Point2D adjustedLayout = new Point2D( ( layout.getX() - parentView.getBoundsInParent().getWidth() / 2 ),
                                              layout.getY() );
       
        MultiArgPremiseConnectionNode multiArgPremiseConnection = new MultiArgPremiseConnectionNode
                                                                    ( premiseNumber, adjustedLayout );

        return multiArgPremiseConnection;
    }

    /**
     * Creates a premise pane whose position is determined relative to its
     * parent PremiseConnectionNode.
     *
     * @param arg ArgumentModel. Backing argument model this premise is a part of
     * 
     * @param parentView Node. JavaFX Node parent of this view structure. Should be 
     *                    a view contained in a PremiseConnectionNode.
     * 
     * @param premiseNumber int. Number representing the prosition of this
     *                       premise within its associated argument.
     *
     * @return ArgumentMode meant to be added to the tree structure
     *
     * @throws IOException in case of FXML load failure
     */
    private ArgumentNode createPremiseView( ArgumentModel arg, Node parentView, int premiseNumber ) throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass().getResource( "/fxml/PremisePane.fxml" ) );
        Pane premisePane  = loader.load();
        Label lbl         = createLabel();
        PremisePaneController premiseControl = loader.<PremisePaneController>getController();
        premiseControl.setPosition( premiseNumber );
        premiseControl.setArgumentViewTree( this );
        premiseControl.setArgumentModel( arg );
        premiseControl.setConnectionNode( this.premiseConnectionNodes.get( premiseNumber ) );
        premiseControl.setParentControl( canvasControl );
        premiseControl.setSchemeLabel( lbl );
        premiseControl.setProCon( arg.getSchemeModel().getPremises().get( premiseNumber ).getProCon() );
        
        lbl.setText( arg.getSchemePremise( premiseNumber ) );
        Point2D layout = getRelativeLayout( parentView );
        Point2D adjustedLayout = new Point2D(
                               ( int ) ( layout.getX() - PREMISE_WIDTH / 2 ),
                               ( int ) ( layout.getY() ) );

        LayoutUtils.setChildLayout( premisePane, adjustedLayout );
        premiseControl.initializePane();

        return new PremiseNode( premisePane, premiseControl );
    }

    /**
     * Creates a new pane and ArgumentNode for the conclusion to multiple
     * arguments that share the same conclusion. Uses the conclusion
     * proposition.
     *
     * @param parentNode ArgumentNode parent of the created node
     * @param conclusionControl
     * @param premiseControl
     *
     * @return
     *
     * @throws IOException
     */
    private ArgumentNode createMultiArgChainViewConclusion( ArgumentNode parentNode,
                                                            ConclusionPaneController conclusionControl,
                                                            PremisePaneController premiseControl )
                                                            throws IOException
    {
        System.out.println( "HERE?!?!?" );
        FXMLLoader loader = new FXMLLoader( getClass() .getResource( "/fxml/MultiArgChainPane.fxml" ) );
        Pane chainPane    = loader.load();
        MultiArgChainPaneController chainControl = loader.<MultiArgChainPaneController>getController();
        conclusionControl.getConclusionArgumentModelList().forEach( ( arg ) -> 
        {
            chainControl.addConclusionArgumentModel( arg );
        });

        chainControl.addPremiseArgument( premiseControl.getArgument() );
        chainControl.setArgumentViewTree( this );
        chainControl.setParentControl( canvasControl );
        chainControl.setPosition( premiseControl.getPosition() );
        chainControl.setPropositionModel( conclusionControl.getConclusionArgumentModel()
                                         .getConclusion().getProposition() );

        Point2D layout         = getRelativeLayout( parentNode.getView() );
        Point2D adjustedLayout = new Point2D( ( int ) ( layout.getX()  ),
                                              ( int )   layout.getY() );

        LayoutUtils.setChildLayout( chainPane, adjustedLayout );
        return new ChainNode( chainPane, chainControl );
    }

    /**
     * Creates a new pane and ArgumentNode for the conclusion to multiple
     * arguments that share the same conclusion. Uses the premise proposition.
     *
     * @param parentNode
     * @param conclusionControl
     * @param premiseControl
     *
     * @return
     *
     * @throws IOException
     */
    private ArgumentNode createMultiArgChainViewPremise( ArgumentNode parentNode, ConclusionPaneController conclusionControl,
                                                         PremisePaneController premiseControl ) throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass().getResource( "/fxml/MultiArgChainPane.fxml" ) );
        Pane chainPane    = loader.load();
        MultiArgChainPaneController chainControl = loader.<MultiArgChainPaneController>getController();

        conclusionControl.getConclusionArgumentModelList().forEach( ( arg ) ->
        {
            chainControl.addConclusionArgumentModel( arg );
        } );

        chainControl.addPremiseArgument( premiseControl.getArgument() );
        chainControl.setArgumentViewTree( this );
        chainControl.setParentControl( canvasControl );
        chainControl.setPosition( premiseControl.getPosition() );
        chainControl.setPropositionModel( premiseControl.getProposition() );

        Point2D layout         = getRelativeLayout( parentNode.getView() );
        Point2D adjustedLayout = new Point2D( ( int ) ( layout.getX() - PREMISE_WIDTH / 2 ),
                                              ( int ) layout.getY() );

        LayoutUtils.setChildLayout( chainPane, adjustedLayout );
        return new ChainNode( chainPane, chainControl );
    }

    /**
     * Creates a ChainPane as part of a merger procedure, inheriting the
     * properties and fields of the conclusion being merged in to this tree
     *
     * @param parentNode ArgumentNode parent of the point of merger
     * @param conclusionControl ConclusionPaneController controller of the
     * conclusion being merged in
     * @param premiseControl PremisePaneController controller of the premise
     * that is being merged into
     *
     * @return ArgumentNode the created Chain Pane
     *
     * @throws IOException
     */
    private ArgumentNode createChainViewConclusion( ArgumentNode parentNode, ConclusionPaneController conclusionControl,
                                                    PremisePaneController premiseControl ) throws IOException
    {
        ChainPaneController chainControl = generateChainNode();

        chainControl.addConclusionArgumentModel( conclusionControl.getConclusionArgumentModel() );
        chainControl.addPremiseArgument( premiseControl.getArgument() );
        chainControl.setArgumentViewTree( this );
        chainControl.setParentControl( canvasControl );
        chainControl.setCertaintyController( conclusionControl.getCertaintyController() );
        chainControl.setPosition( premiseControl.getPosition() );
        chainControl.setPropositionModel( conclusionControl.getConclusionArgumentModel().getConclusion().getProposition() );
        chainControl.checkHasProp();

        //
        // Algorithm Description:
        //
        // We need a way to fix the lines not translating properly when the user
        // drags the entire tree. A way around this is to just grab the screen
        // coordinates of the line, and depending on if its drug to the left or
        // the right of its original position, we assign the x coordinate of the 
        // adjusted layout to be the bounds max or min x value (top right/left 
        // respectively).
        //
        //
        Node node                = premiseControl.getConnectionNode().getView();
        Bounds boundsInScreen    = FXUtils.nodePosition( node );
        Point2D layout           = getRelativeLayout ( parentNode.getView()    );
        
        double appropriateBoundX = Math.signum( premiseControl.getMainPane().getTranslateX() ) > 0.0 ? 
                                                boundsInScreen.getMaxX() : 
                                                boundsInScreen.getMinX() ;
        
        Point2D adjustedLayout   = new Point2D( ( int ) appropriateBoundX,
                                                ( int ) layout.getY() );

        LayoutUtils.setChildLayout( chainControl.getMainPane(), adjustedLayout );
        return new ChainNode( chainControl.getMainPane(), chainControl );
    }

    /**
     * Creates a ChainPane as part of a merger procedure, inheriting the
     * properties and fields of the premise that is being merged into
     *
     * @param parentNode ArgumentNode parent of the point of merger
     * @param conclusionControl ConclusionPaneController controller of the
     * conclusion being merged in
     * @param premiseControl PremisePaneController controller of the premise
     * that is being merged into
     *
     * @return ArgumentNode the created Chain Pane
     *
     * @throws IOException
     */
    private ArgumentNode createChainViewPremise( ArgumentNode parentNode, ConclusionPaneController conclusionControl,
                                                 PremisePaneController premiseControl ) throws IOException
    {
        ChainPaneController chainControl = generateChainNode();

        chainControl.setArgumentViewTree( this );
        chainControl.addConclusionArgumentModel( conclusionControl.getConclusionArgumentModel() );
        chainControl.addPremiseArgument( premiseControl.getArgument() );
        chainControl.setParentControl( canvasControl );
        chainControl.setCertaintyController( premiseControl.getCertaintyController() );
        chainControl.setPosition( premiseControl.getPosition() );
        chainControl.setPropositionModel( premiseControl.getProposition() );
        chainControl.setConnectionNode( premiseControl.getConnectionNode() );
        chainControl.checkHasProp();

        //
        // Algorithm Description:
        //
        // We need a way to fix the lines not translating properly when the user
        // drags the entire tree. A way around this is to just grab the screen
        // coordinates of the line, and depending on if its drug to the left or
        // the right of its original position, we assign the x coordinate of the 
        // adjusted layout to be the bounds max or min x value (top right/left 
        // respectively).
        //
        //
        Node node                = premiseControl.getConnectionNode().getView();
        Bounds boundsInScreen    = FXUtils.nodePosition( node );
        Point2D layout           = getRelativeLayout ( parentNode.getView()    );
        
        double appropriateBoundX = Math.signum( premiseControl.getMainPane().getTranslateX() ) > 0.0 ? 
                                                boundsInScreen.getMaxX() : 
                                                boundsInScreen.getMinX() ;
        
        Point2D adjustedLayout   = new Point2D( ( int ) appropriateBoundX,
                                                ( int ) layout.getY() );
           
        LayoutUtils.setChildLayout( chainControl.getMainPane(), adjustedLayout );
        return new ChainNode( chainControl.getMainPane(), chainControl );
    }

    /**
     * Creates a Chain Pane and its associated node
     *
     * @return ChainPaneController the controller of the chain pane
     *
     * @throws IOException
     */
    private ChainPaneController generateChainNode() throws IOException
    {
        FXMLLoader loader                = new FXMLLoader( getClass().getResource( "/fxml/ChainPane.fxml" ) );
        Pane chainPane                   = loader.load();
        ChainPaneController chainControl = loader.<ChainPaneController>getController();
        return chainControl;
    }

    /**
     * Creates a new conclusion for multiple arguments that share the same
     * conclusion when a multi-arg structure is being detached
     *
     * @param multiChainNode
     * @param multiChainControl
     *
     * @return
     *
     * @throws IOException
     */
    private ConclusionNode createNewMultiArgConclusion( ArgumentNode multiChainNode, MultiArgChainPaneController multiChainControl )
                                                        throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass().getResource( "/fxml/MultiArgConclusionPane.fxml" ) );
        Pane multiArgPane = loader.load();
        MultiArgConclusionPaneController multiArgControl = loader.<MultiArgConclusionPaneController>getController();

        multiChainControl.getConclusionArgumentModelList().forEach( ( arg ) ->
        {
            multiArgControl.addConclusionArgumentModel( arg );
        } );
        
        multiArgControl.setParentControl( canvasControl );

        if ( multiChainControl.getProposition() != null )
        {
            multiArgControl.setPropositionModel( multiChainControl.getProposition() );
        }

        Point2D adjustedLayout = new Point2D( ( int ) multiChainNode.getView().getBoundsInParent().getMinX(),
                                              ( int ) multiChainNode.getView().getBoundsInParent().getMinY() );

        LayoutUtils.setChildLayout( multiArgPane, adjustedLayout );
        return new ConclusionNode( multiArgPane, multiArgControl );
    }

    /**
     * Method creates the circular CQ icon
     *
     * @param parentNode ArgumentNode parent of the icon
     *
     * @return CQIcon ArgumentNode
     *
     * @throws IOException
     */
    private CQIcon createCQIcon( ArgumentNode parentNode ) throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass().getResource( "/fxml/CriticalIconFXML.fxml" ) );
        Pane cqIcon = loader.load();

        Point2D targetCoords = new Point2D( parentNode.getView().getBoundsInParent().getMinX() - 100,
                                            parentNode.getView().getBoundsInParent().getMinY() - 50 );
        LayoutUtils.setChildLayout( cqIcon, targetCoords );
        return new CQIcon( cqIcon );
    }

    /**
     * Creates a CQPane to contain an answer to a counter argument
     *
     * @param arg ArgumentModel the response to the CQ
     * @param parentArg ArgumentModel that poses the CQ
     * @param parent ArgumentNode parent node in the tree structure
     *
     * @return ArgumentNode the ArgumentNode
     *
     * @throws IOException
     */
    private ArgumentNode createCQView( ArgumentModel arg, ArgumentModel parentArg, 
                                       ArgumentNode parent, PremiseConnectionNode connector, int cqNum ) throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass().getResource( "/fxml/CQPane.fxml" ) );
        Pane cqPane = loader.load();
        CQPaneController cqControl = loader.<CQPaneController>getController();
        cqControl.setArgumentViewTree( this );
        cqControl.setArgumentModel( arg );
        cqControl.setParentArgument( parentArg );
        cqControl.setParentControl( canvasControl );
        cqControl.setConnector( parent );
        
        // Sets the color of the line attaching the cq to the main connector
        //( ( Line ) ( connector.getView() ) ).setStroke( Color.AQUAMARINE );
        cqControl.setConnectionNode( connector );
        cqControl.setCQNum( cqNum );
        cqControl.setText( "CQ " + parentArg.getPatchCriticalQuestion( cqNum ) );
        Point2D layout = getRelativeLayout( parent.getView() );
        Point2D adjustedLayout = new Point2D( ( int ) layout.getX() ,
                                              ( int ) layout.getY() );
        LayoutUtils.setChildLayout( cqPane, adjustedLayout );
        return new CQNode( cqPane, cqControl );
    }
    
    /**
     * Creates a CQPane to contain an answer to a counter argument
     *
     * @param arg ArgumentModel the response to the CQ
     * @param parentArg ArgumentModel that poses the CQ
     * @param parent ArgumentNode parent node in the tree structure
     *
     * @return ArgumentNode the ArgumentNode
     *
     * @throws IOException
     */
    private ArgumentNode createCQView( ArgumentModel arg, ArgumentModel parentArg, 
                                       ArgumentNode parent ) throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass().getResource( "/fxml/CQPane.fxml" ) );
        Pane cqPane = loader.load();
        CQPaneController cqControl = loader.<CQPaneController>getController();
        cqControl.setArgumentViewTree( this );
        cqControl.setArgumentModel( arg );
        cqControl.setParentArgument( parentArg );
        cqControl.setParentControl( canvasControl );
        cqControl.setConnector( parent );
        Point2D layout = getRelativeLayout( parent.getView() );
        Point2D adjustedLayout = new Point2D( ( int ) layout.getX() + parent.getWidth() - 163,
                                              ( int ) layout.getY() );
        LayoutUtils.setChildLayout( cqPane, adjustedLayout );
        return new CQNode( cqPane, cqControl );
    }    

    private ArgumentNode createCQConnection( ArgumentModel arg, ArgumentNode parentNode )
    {
        ArgumentNode targetNexus = findNextNexus( parentNode );
        Point2D parentLayout     = getRelativeLayout( parentNode.getView() );
        Point2D nexusLayout      = getRelativeLayout( targetNexus.getView() );
        Point2D adjustedLayout   = new Point2D( nexusLayout.getX(), nexusLayout.getY() - 100 );
        CQConnectionNode cqConnection = new CQConnectionNode( adjustedLayout );

        return cqConnection;
    }

    /**
     * Method creates an pane using values from the conclusion of the merge
     *
     * @param parentNode
     * @param conclusionControl
     * @param cqControl
     *
     * @return
     *
     * @throws IOException
     */
    private ArgumentNode createCQArgPaneConclusion( ArgumentNode parentNode, ConclusionPaneController conclusionControl,
                                                    CQPaneController cqControl ) throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass().getResource( "/fxml/CQArgumentPane.fxml" ) );
        Pane cqArgPane = loader.load();
        CQArgumentPaneController cqArgControl = loader.<CQArgumentPaneController>getController();
        cqArgControl.setArgumentModel( conclusionControl.getConclusionArgumentModel() );
        cqArgControl.setParentArgument( cqControl.getParentArgument() );
        cqArgControl.setArgumentViewTree( this );
        cqArgControl.setParentControl( canvasControl );
        cqArgControl.setCertaintyController( conclusionControl.getCertaintyController() );
        if ( conclusionControl.getConclusionArgumentModel().getConclusion() != null )
        {
            System.out.println( "setting prop model" );
            System.out.println( conclusionControl.getConclusionArgumentModel().getConclusion().getProposition() );
            cqArgControl.setPropositionModel( conclusionControl.getConclusionArgumentModel().getConclusion().getProposition() );
        }
        
        Point2D layout = getRelativeLayout( parentNode.getView() );
        Point2D adjustedLayout = new Point2D( ( int ) layout.getX() + cqControl.getConnector().getWidth() - 163,
                                              ( int ) layout.getY() );
        
        LayoutUtils.setChildLayout( cqArgPane, adjustedLayout );
        return new CQArgumentNode( cqArgPane, cqArgControl );
    }

    /**
     * Creates a CQ pane with the values from the premise side of the merge
     *
     * @param parentNode
     * @param conclusionControl
     * @param cqControl
     *
     * @return
     *
     * @throws IOException
     */
    private ArgumentNode createCQArgPanePremise( ArgumentNode parentNode, ConclusionPaneController conclusionControl,
                                                 CQPaneController cqControl) throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass().getResource( "/fxml/CQArgumentPane.fxml" ) );
        Pane cqArgPane = loader.load();
        CQArgumentPaneController cqArgControl = loader.<CQArgumentPaneController>getController();
        cqArgControl.setArgumentModel( conclusionControl.getConclusionArgumentModel() );
        cqArgControl.setParentArgument( cqControl.getParentArgument() );
        cqArgControl.setArgumentViewTree( this );
        cqArgControl.setParentControl( canvasControl );
        cqArgControl.setCertaintyController( cqControl.getCertaintyController() );
        cqArgControl.setPropositionModel( cqControl.getProposition() );

        Point2D layout = getRelativeLayout( parentNode.getView() );
        Point2D adjustedLayout = new Point2D( ( int ) layout.getX() + cqControl.getConnector().getWidth() - 163, ( int ) layout.getY() );

        LayoutUtils.setChildLayout( cqArgPane, adjustedLayout );

        return new CQArgumentNode( cqArgPane, cqArgControl );
    }

    /**
     * Creates the shield Icon for counter arguement structure
     *
     * @param parent ArgumentNode parent of the icon
     *
     * @return
     *
     * @throws IOException
     */
    private ArgumentNode createCounterIcon( ArgumentNode parent ) throws IOException
    {
        FXMLLoader loader    = new FXMLLoader( getClass().getResource( "/fxml/CounterShieldFXML.fxml" ) );
        Pane counterIcon     = loader.load();

        Point2D targetCoords = new Point2D( parent.getView().getBoundsInParent().getMaxX(),
                                            parent.getView().getBoundsInParent().getMinY() - 70 );
        LayoutUtils.setChildLayout( counterIcon, targetCoords );
        return new CounterIcon( counterIcon );
    }

    /**
     * Creates a counter proposition view. Counter proposition views are counter
     * arguments that do not have a proper argument attached to them
     *
     * @param parentModelList
     * @param counterArg
     * @param parent
     *
     * @return
     *
     * @throws IOException
     */
    private ArgumentNode createCounterPropositionView( List<PremiseModel> parentModelList, CounterArgumentModel counterArg,
                                                       ArgumentNode specificCounterConnector, ArgumentNode parent ) throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass().getResource( "/fxml/CounterPropositionPane.fxml" ) );
        Pane counterPane = loader.load();
        CounterPropositionPaneController counterControl = loader.<CounterPropositionPaneController>getController();
        counterControl.setArgumentViewTree( this );
        counterControl.setArgumentModel( counterArg );
        counterControl.setParentModelList( parentModelList );
        counterControl.setParentControl( canvasControl );
        counterControl.setParent( parent );
        Point2D layout = getRelativeLayout( specificCounterConnector.getView() );

        Point2D adjustedLayout;
        adjustedLayout = new Point2D( ( int ) layout.getX() - ( PREMISE_WIDTH / 2 ),
                                      ( int ) layout.getY() );

        LayoutUtils.setChildLayout( counterPane, adjustedLayout );
        return new CounterPropositionNode( counterPane, counterControl );
    }
    
    public ArgumentNode createProArgumentConnection( Node parentView )
    {
        Point2D adjustedLayout = new Point2D( parentView.getBoundsInParent().getMinX(),
                                              parentView.getBoundsInParent().getMinY() );
        
        ProArgumentConnectionNode proConnection = new ProArgumentConnectionNode( adjustedLayout );
        return proConnection;
    }

    /**
     * Creates the connector between an argument and its counter arguments
     *
     * @param parentView
     *
     * @return
     */
    private ArgumentNode createCounterArgumentConnection( Node parentView )
    {
        //Bounds adjustedBounds = parentView.localToScreen( parentView.getBoundsInLocal() );
           //     System.out.println( adjustedBounds );
        Point2D adjustedBounds = new Point2D( parentView.getBoundsInParent().getMaxX(),
                                              parentView.getBoundsInParent().getMaxY() - 120 );
//
//        Point2D adjustedLayout = new Point2D( adjustedBounds.getMaxX(), 
//                                              adjustedBounds.getMaxY() - 120 );

        CounterArgumentConnectionNode counterConnection = new CounterArgumentConnectionNode( adjustedBounds );

        return counterConnection;
    }

    /**
     * Creates a counter argument pane using the values of the conclusion side
     * of a merge
     *
     * @param parentNode
     * @param conclusionControl
     * @param counterControl
     *
     * @return
     *
     * @throws IOException
     */
    private ArgumentNode createCounterArgumentViewConclusion( ArgumentNode parentNode, ConclusionPaneController conclusionControl,
                                                              CounterPropositionPaneController counterControl ) throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass().getResource( "/fxml/CounterArgumentPane.fxml" ) );
        Pane counterArgumentPane = loader.load();
        CounterArgumentPaneController counterArgumentControl = loader.<CounterArgumentPaneController>getController();
        /*
         * remove the proposition counter argument from the parent argument's
         * counter arg list, replace it with the new merged conclusion's
         * argument
         */
        // get variable's set up for readability
        List<PremiseModel> parentModelList = counterControl.getParentModelList();
        List<List<CounterArgumentModel>> parentCounterArgLists = new ArrayList<>();

        parentModelList.forEach( ( model ) ->
        {
            parentCounterArgLists.add( model.getCounterArgumentList() );
        } );

        ArgumentModel propCounterArg = counterControl.getArgument();
        ArgumentModel conclusionArgument = conclusionControl.getConclusionArgumentModel();
        CounterArgumentModel newCounterArgument = new CounterArgumentModel( conclusionArgument );

        parentCounterArgLists.forEach( ( counterArgList ) ->
        {
            int indexOfPropCounter = counterArgList.indexOf( propCounterArg );

            // the actual swap
            counterArgList.remove( propCounterArg );
            counterArgList.add( indexOfPropCounter, newCounterArgument );
        } );

        /*
         * assign the fields for the created counter argument pane
         */
        counterArgumentControl.setArgumentModel( newCounterArgument );
        counterArgumentControl.setParentModelList( parentModelList );
        counterArgumentControl.setParentControl( canvasControl );
        counterArgumentControl.addProposition( conclusionControl.getProposition() );
        counterArgumentControl.setArgumentViewTree( this );
        counterArgumentControl.setCertaintyController( conclusionControl.getCertaintyController() );
        counterArgumentControl.setPosition( counterControl.getPosition() );

        Point2D layout = getRelativeLayout( parentNode.getView() );
        Point2D adjustedLayout = new Point2D( ( int ) ( layout.getX() - PREMISE_WIDTH / 2 ),
                                              ( int ) ( layout.getY() ) );
        LayoutUtils.setChildLayout( counterArgumentPane, adjustedLayout );
        return new CounterArgumentNode( counterArgumentPane, counterArgumentControl );
    }

    /**
     * Creates a counter argument pane using the values from the premise side of
     * a merge
     *
     * @param parentNode
     * @param conclusionControl
     * @param counterControl
     *
     * @return
     *
     * @throws IOException
     */
    private ArgumentNode createCounterArgumentViewPremise( ArgumentNode parentNode, ConclusionPaneController conclusionControl,
                                                           CounterPropositionPaneController counterControl ) throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass().getResource( "/fxml/CounterArgumentPane.fxml" ) );
        Pane counterArgumentPane = loader.load();
        CounterArgumentPaneController counterArgumentControl = loader.<CounterArgumentPaneController>getController();

        /*
         * Remove the proposition counter argument from the parent argument's
         * counter arg list, replace it with the new merged conclusion's
         * argument
         */
        // get variable's set up for readability
        List<PremiseModel> parentModelList = counterControl.getParentModelList();
        List<List<CounterArgumentModel>> parentCounterArgLists = new ArrayList<>();

        
        parentModelList.forEach( ( model ) ->
        {
            parentCounterArgLists.add( model.getCounterArgumentList() );
        } );

        ArgumentModel propCounterArg            = counterControl.getArgument();
        ArgumentModel conclusionArgument        = conclusionControl.getConclusionArgumentModel();
        CounterArgumentModel newCounterArgument = new CounterArgumentModel( conclusionArgument );

        parentCounterArgLists.forEach( ( counterArgList ) ->
        {
            int indexOfPropCounter = counterArgList.indexOf( propCounterArg );
            // the actual swap
            counterArgList.remove( propCounterArg );
            counterArgList.add( indexOfPropCounter, newCounterArgument );
        } );
        counterArgumentControl.setArgumentModel( newCounterArgument );
        counterArgumentControl.setParentModelList( parentModelList );
        counterArgumentControl.setParentControl( canvasControl );
        counterArgumentControl.addProposition( counterControl.getProposition() );
        counterArgumentControl.setArgumentViewTree( this );

        counterArgumentControl.setCertaintyController( counterControl.getCertaintyController() );
        counterArgumentControl.setPosition( counterControl.getPosition() );

        Point2D layout = getRelativeLayout( parentNode.getView() );
        Point2D adjustedLayout = new Point2D( ( int ) ( layout.getX() - PREMISE_WIDTH / 2 ),
                                              ( int ) ( layout.getY() ) );
        LayoutUtils.setChildLayout( counterArgumentPane, adjustedLayout );
        
        return new CounterArgumentNode( counterArgumentPane, counterArgumentControl );
    }

    /**
     * Creates a view for an individual conclusion in a multiple-arguments
     * sharing the same conclusion structure
     *
     * @param arg
     * @param parentView
     * @param certaintyControl
     * @param pos
     *
     * @return
     *
     * @throws IOException
     */
    private ArgumentNode createMultiArgSubView( ArgumentModel arg, Node parentView,
                                                ArgumentCertaintyPaneController certaintyControl, int pos ) 
                                                throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass().getResource( "/fxml/MultiArgSubConclusionPane.fxml" ) );
        Pane premisePane = loader.load();
        MultiArgSubConclusionPaneController subConControl = loader.<MultiArgSubConclusionPaneController>getController();
        subConControl.setArgumentViewTree( this );
        subConControl.setArgument( arg );
        subConControl.setParentControl( canvasControl );
        subConControl.setCertaintyControl( certaintyControl );

        Point2D layout = getRelativeLayout( parentView );
        Point2D adjustedLayout = new Point2D( ( int ) ( layout.getX() - ( 40 / 2 ) ),
                                              ( int ) layout.getY() );

        LayoutUtils.setChildLayout( premisePane, adjustedLayout );

        return new MultiArgSubNode( premisePane, subConControl );
    }

    /**
     * Creates a model for multiple arguments sharing the same conclusion
     *
     * @param parentView
     *
     * @return
     */
    private ArgumentNode createMultiArgLabel( Node parentView )
    {
        Point2D layout = getRelativeLayout( parentView );
        ArgumentNode label = new MultipleArgLabel( layout, this, canvas );

        return label;
    }

    /**
     * Creates a pane for the conclusion of multiple arguments sharing the same
     * conclusion with values taken from the conclusion side of a merge
     *
     * @param mainConNode
     * @param mainConControl
     * @param mergeConControl
     *
     * @return
     *
     * @throws IOException
     */
    private ConclusionNode createNewMultiArgConclusion( ArgumentNode mainConNode, ConclusionPaneController mainConControl,
                                                        ConclusionPaneController mergeConControl ) throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass().getResource( "/fxml/MultiArgConclusionPane.fxml" ) );
        Pane multiArgPane = loader.load();
        MultiArgConclusionPaneController multiArgControl = loader.<MultiArgConclusionPaneController>getController();

        multiArgControl.setArgumentViewTree( this );
        multiArgControl.addConclusionArgumentModel( mainConControl.getConclusionArgumentModel() );
        multiArgControl.addConclusionArgumentModel( mergeConControl.getConclusionArgumentModel() );
        multiArgControl.setParentControl( canvasControl );

        //mainConControl.getProposition().setProposition( mainConControl.getTextInTextArea() );
        //multiArgControl.getPropositionBoxController().setText( mainConControl.getPropositionBoxController().getTextAreaText() );
        multiArgControl.setPropositionModel( mainConControl.getProposition() );
        multiArgControl.addProposition( mainConControl.getProposition() );
        
        
        Point2D adjustedLayout = new Point2D( ( int ) mainConNode.getView().getBoundsInParent().getMinX(),
                                              ( int ) mainConNode.getView().getBoundsInParent().getMinY() );

        LayoutUtils.setChildLayout( multiArgPane, adjustedLayout );
        return new ConclusionNode( multiArgPane, multiArgControl );
    }

    private ChainNode createMultiArgChainView( ConclusionPaneController conclusionControl,
                                               ChainPaneController      chainControl ) throws IOException
    {
        FXMLLoader loader = new FXMLLoader( getClass().getResource( "/fxml/MultiArgChainPane.fxml" ) );
        Pane chainPane = loader.load();
        MultiArgChainPaneController multiChainControl = loader.<MultiArgChainPaneController>getController();
        if ( chainControl.getCQFlag() )
        {
            multiChainControl.setCQFlag();
            multiChainControl.setConnector( chainControl.getConnector() );
        }
        if ( chainControl.getCounterFlag() )
        {
            multiChainControl.setCounterFlag();
            multiChainControl.setConnector( chainControl.getConnector() );
        }
        conclusionControl.getConclusionArgumentModelList().forEach( ( arg ) ->
        {
            multiChainControl.addConclusionArgumentModel( arg );
        } );

        chainControl.getConclusionArgumentModelList().forEach( ( arg ) ->
        {
            multiChainControl.addConclusionArgumentModel( arg );
        } );
        multiChainControl.addPremiseArgument( chainControl.getPremiseArgument() );
        multiChainControl.setArgumentViewTree( this );
        multiChainControl.setParentControl( canvasControl );

        multiChainControl.setPosition( chainControl.getPosition() );

        multiChainControl.setPropositionModel( chainControl.getProposition() );
        
        multiChainControl.setConnectionNode( chainControl.getConnectionNode() );


        multiChainControl.getMainPane().setLayoutX( chainControl.getMainPane().getLayoutX() );
        multiChainControl.getMainPane().setLayoutY( chainControl.getMainPane().getLayoutY() );
        
        Bounds multiChainBounds = FXUtils.nodePosition( conclusionControl.getMainPane() );
        
        System.out.println( multiChainBounds );
        
        ( ( Line ) chainControl.getConnectionNode().getView() ).setEndX( multiChainBounds.getMinX() + PREMISE_WIDTH / 2 );
        ( ( Line ) chainControl.getConnectionNode().getView() ).setEndY( multiChainBounds.getMinY() );
        
        return new ChainNode( chainPane, multiChainControl );
    }

    /**
     * Opens a dialogue window for the user to pick which proposition will be
     * carried over when chaining arguments
     *
     * @return ChainPropositionChoice which is an enum value specifying the
     * users selection
     *
     * @throws IOException
     */
    private ChainPropositionChoice showPropositionChoiceDialogue() throws IOException
    {
        FXMLLoader loader    = new FXMLLoader( getClass().getResource( "/fxml/ChainTwoPropWarningPane.fxml" ) );
        Parent propChoiceBox = loader.load();
        ChainTwoPropWarningPaneController propChoiceControl = loader.<ChainTwoPropWarningPaneController>getController();
        Scene scene = new Scene( propChoiceBox );
        Stage stage = new Stage();
        stage.setTitle( "Choose proposition" );
        stage.setScene( scene );
        stage.initModality( Modality.APPLICATION_MODAL );
        stage.initOwner( canvas.getScene().getWindow() );
        stage.showAndWait();
        return propChoiceControl.getUserPropositionChoice();
    }

    /**
     * Calculates the appropriate layout of a Node relative to its parent. This
     * method should return a point that is the the bottom center of a parent
     * view.
     *
     * @param parentView Node. Parent JavaFX Node meant to be used as a
     * reference for calculating the desired Point coordinates
     *
     * @return Point2D coordinates detailing a point at the bottom center of the
     * specified parent Node
     */
    private Point2D getRelativeLayout( Node parentView )
    {
        canvas.layout();
        Bounds parentBounds = parentView.getBoundsInParent();
        double parentHeight = parentBounds.getHeight();
        double parentWidth  = parentBounds.getWidth();

        double targetX      = parentBounds.getMinX() + ( parentWidth / 2 );
        double targetY      = parentBounds.getMinY() + parentHeight;
        Point2D localCoords = new Point2D( targetX, targetY );
        return localCoords;
    }
    
    public void translateTree( ArgumentViewTree tree, double x, double y )
    {
        double transX = x - root.getView().getLayoutX();
        double transY = y - root.getView().getLayoutY();
        translateNode( root, transX, transY );
    }    

    /**
     * Calculates the translation necessary for relocating a node to the
     * specified coordinates. Calls a helper method that recursively iterates
     * through the tree to translate all child nodes
     *
     * @param x double. Destination X coordinate
     * @param y double. Destination Y coordinate
     */
    public void translateTree( double x, double y )
    {
        double transX = x - root.getView().getLayoutX();
        double transY = y - root.getView().getLayoutY();
        translateNode( root, ( int ) transX, ( int ) transY );
    }
    

    public void shiftNode( ArgumentNode node, int x, int y )
    {
        node.getView().setTranslateX( ( int ) ( node.getView().getTranslateX() + x ) );
        node.getView().setTranslateY( ( int ) ( node.getView().getTranslateY() + y ) );
        node.moveComment( x, y );
    }    

    /**
     * Helper method that translates a node by the specified X and Y amounts,
     * then recursively processes all child ArgumentNodes
     *
     * @param node ArgumentNode to be translated
     * @param x double. Translation amount on X plane
     * @param y double. Translation amount on Y plane
     */
    public void translateNode( ArgumentNode node, double x, double y )
    {
        node.getView().setLayoutX( ( int ) ( node.getView().getLayoutX() + x ) );
        node.getView().setLayoutY( ( int ) ( node.getView().getLayoutY() + y ) );
        node.moveComment( x, y );
        node.getChildren().forEach( ( child ) ->
        {
            this.translateNode( child, x, y );
        } );
    }

    /**
     * Method for attaching a subtree to an existing tree.
     *
     * @param newNode ArgumentNode point of connection between the two trees
     * @param oldNode ArgumentNode that is replaced by newNode
     * @param parent ArgumentNode parent of oldNode
     * @param subTree ArgumentViewTree that will be attached
     * @param subTreeID String ID of subtree
     */
    private void attachNewSubTree( ArgumentNode newNode, ArgumentNode oldNode,
                                   ArgumentNode parent , ArgumentViewTree subTree, String subTreeID )
    {
        newNode.setParent( parent );
        this.rearrangeChildren( parent, oldNode, newNode, subTree );
        this.updateNexusMatrix( newNode, subTree );
        this.updatePaneMatrix( oldNode, newNode, subTree );
        this.canvasControl.removeArgumentTree( subTreeID );
    }

    /**
     * Method to delete all comments in an argument view tree
     */
    public void deleteCommentPanes()
    {
        root.deleteCommentPane();
        deleteCommentPane( root );
    }

    /**
     * Recursive helper method to delete all comments in a tree
     *
     * @param node
     */
    public void deleteCommentPane( ArgumentNode node )
    {
        node.deleteCommentPane();
        node.getChildren().forEach( ( child ) ->
        {
            deleteCommentPane( child );
        } );
    }

    /**
     * Recursively goes through an ArgumentViewTree starting at the specified
     * ArgumentNode and sets its ArgumentViewTree reference to this tree
     *
     * @param node ArgumentNode
     */
    private void changeArgTree( ArgumentNode node )
    {
        node.setArgTree( this );
        node.getChildren().forEach( ( child ) ->
        {
            changeArgTree( child );
        } );
    }

    private ArgumentNode searchForNode( ArgumentNode node, Pane target )
    {
        if ( node.getView().equals( target ) )
        {
            return node;
        }
        
        ArgumentNode result = null;
        
        for ( int i = 0; result == null && i < node.getChildren().size(); i++ )
        {
            result = searchForNode( node.getChildren().get( i ), target );
        }
        return result;
    }

    /**
     * Reassigns children/parent relations when merging argument structures.
     *
     * @param targetParent ArgumentNode parent of the target node
     * @param target ArgumentNode point of merger, will be replaced by a new
     * type of node that will link the two argument structures
     * @param chainNode ArgumentNode new argument node meant to link the two
     * argument structures
     * @param mergedTree ArgumentViewTree being merged into this one
     */
    private void rearrangeChildren( ArgumentNode targetParent, ArgumentNode target,
                                    ArgumentNode chainNode   , ArgumentViewTree mergedTree )
    {
        targetParent.removeChild( target );
        targetParent.addAsChild( chainNode );

        ListIterator<ArgumentNode> targetChildren  = target.getChildren().listIterator();
        while ( targetChildren.hasNext() )
        {
            ArgumentNode child = targetChildren.next();
            chainNode.addAsChild( child );
            child.setParent( chainNode );
            targetChildren.remove();
        }

        canvas.getChildren().add( chainNode.getView() );
        canvas.getChildren().remove( target.getView() );

        mergedTree.translateTree( chainNode.getView().getLayoutX(),
                                  chainNode.getView().getLayoutY() );

        ArgumentNode               mergedTreeRoot  = mergedTree.getRoot();
        ListIterator<ArgumentNode> oldTreeChildren = mergedTreeRoot.getChildren().listIterator();
        while ( oldTreeChildren.hasNext() )
        {
            ArgumentNode child = oldTreeChildren.next();
            chainNode.addAsChild( child );
            child.setParent( chainNode );
            changeArgTree( child );
            oldTreeChildren.remove();
        }
        canvas.getChildren().remove( mergedTreeRoot.getView() );
    }

    /**
     * Check if this tree contains the specified node
     *
     * @param node ArgumentNode being searched for
     *
     * @return boolean
     */
    public boolean containsNode( ArgumentNode node )
    {
        return containsNode( root, node );
    }

    /**
     * Recursive helper method to traverse the tree searching for target
     * ArgumentNode
     *
     * @param current ArgumentNode being inspected
     * @param target ArgumentNode being searched for
     *
     * @return boolean
     */
    private boolean containsNode( ArgumentNode current, ArgumentNode target )
    {
        if ( current.equals( target ) )
        {
            return true;
        }

        boolean targetFound = false;
        for ( int i = 0;  ! targetFound && i < current.getChildren().size(); i ++ )
        {
            targetFound = containsNode( current.getChildren().get( i ), target );
        }
        return targetFound;
    }

    /**
     * sets the root of this argument view tree
     *
     * @param root
     */
    private void setRoot( ConclusionNode root )
    {
        this.root = root;
    }

    /**
     * Method deletes this argument structure and erases it from the gui
     */
    public void deleteArgument()
    {
        this.deleteCommentPanes();
        this.eraseTree( root );
        this.canvasControl.removeArgumentTree( treeID );
    }
    
    /**
     * This method recursively minimizes the entire tree from the root. 
     * 
     * If the tree is currently minimized and the user re-opens it, 
     * we check to make sure we don't accidentally open a node that should 
     * remain minimized (such as nexus and connection nodes).
     */
    public void minimizeTreeFromRoot()
    {
        this.minimizeTreeFromRootHelper( this.root );
        this.minimizeTree = ! this.minimizeTree;
    }
    
    private void minimizeTreeFromRootHelper( ArgumentNode node )
    {
        if ( node != this.root ) 
        {
            if ( minimizeTree && ! ( node instanceof CQIcon ) &&
                                 ! ( node instanceof CQLabel ) &&
                                 ! ( node instanceof ArgumentCertaintyNode ) &&
                                 ! ( node instanceof MultiArgConnectionNode ) )
            {
                //
                // If we run into one of the two nexus nodes, we need to do something
                // different if it's a MultiArgPremiseNexusNode because it's the one
                // that actually has to be displayed and isn't used as an anchor
                //
                if ( node instanceof PremiseNexusNode )
                {
                    node.getView().setVisible( ( ( PremiseNexusNode ) node ).multiArg );
                } 
                else
                {
                    node.getView().setVisible( true );
                }
            } 
            else
            {
                node.getView().setVisible( false );
            }
        }
        
        ListIterator<ArgumentNode> it = node.getChildren().listIterator(); 
        
        while( it.hasNext() )
        {
            this.minimizeTreeFromRootHelper( it.next() );
        }
    }    
    
    /**
     * The minimize tree method has two variants, with two more variants of the 
     * helper methods: one with the PremisePaneController parameter, and another 
     * with the ConclusionPaneController to differentiate between premise 
     * and conclusion minimizes. 
     * 
     * The minimizing-recursive algorithm closely resembles the saving algorithm,
     * by traversing through the children of the tree, and backtracking once
     * a leaf [child] node is found.
     * 
     * The following five methods all work together, but only three of the five
     * are ever in use at an arbitrary point in execution.
     * 
     * @param ppc
     * @param minimize 
     */
    public void minimizeTree( PremisePaneController ppc, boolean minimize )
    {
        int _level = 1;
        this.minimizeTreeHelper( root, ppc, _level, minimize );
    }
    
    /**
     * @param cpc
     * @param minimize 
     */
    public void minimizeTree( ConclusionPaneController cpc, boolean minimize )
    {
        int _level = 1;
        this.minimizeTreeHelper( root, cpc, _level, minimize );
    }
    
    public List<ArgumentNode> getChildrenOfPremise( PremisePaneController ppc )
    {
        int _level = 1;
        List<ArgumentNode> children = new LinkedList<>();
        
        this.getChildrenOfPremiseHelper( root, ppc, _level, children );
        
        return children;
    }
  
    
    private void getChildrenOfPremiseHelper( ArgumentNode node, PremisePaneController ppc, 
                                             int treeDepth, List<ArgumentNode> children )
    {
        ListIterator<ArgumentNode> it = node.getChildren().listIterator();
        
        if ( node instanceof PremiseNode )
        {
            PremisePaneController _ppc = ( ( PremiseNode ) node ).getControl();
            
            // If we land on the minimized node, we can start minimizing its children
            if ( _ppc == ppc )
            {
                this.findChildrenOfPremise( node, ppc, treeDepth, treeDepth, children );
                return;

            }
        }
        
        while( it.hasNext() )
        {
            getChildrenOfPremiseHelper( it.next(), ppc, treeDepth, children );
        }
        
        treeDepth -= 2; 
    }
    
    private void findChildrenOfPremise( ArgumentNode node, PremisePaneController ppc, 
                                        int treeDepth, int initialDepth, List<ArgumentNode> children )
    {
        children.add( node );
        
        ListIterator<ArgumentNode> it = node.getChildren().listIterator(); 
        
        if ( node instanceof ConclusionNode || node instanceof PremiseNode )
        {
            treeDepth++;
        }
        
        // Once we've returned/backtracked to the level we began minimizing at,
        // we are done minimizing the subtree [children].
        if ( treeDepth == initialDepth )
        {
            return;
        }
        
        while( it.hasNext() )
        {
            this.findChildrenOfPremise( it.next(), ppc, treeDepth, initialDepth, children );
        }
        
        treeDepth -= 2;        
    }
    
    /**
     * This is actually more for counter arguments...
     * @param cpc
     * @return 
     */
    public List<ArgumentNode> getChildrenOfConclusion( ConclusionPaneController cpc )
    {
        int _level = 1;
        List<ArgumentNode> children = new LinkedList<>();
        
        this.getChildrenOfConclusionHelper( root, cpc, _level, children );
        
        return children;
    }    
    
    private void getChildrenOfConclusionHelper( ArgumentNode node, ConclusionPaneController cpc, 
                                                int treeDepth, List<ArgumentNode> children )
    {
        ListIterator<ArgumentNode> it = node.getChildren().listIterator();
        
        if ( node instanceof ConclusionNode )
        {
            ConclusionPaneController _cpc = ( ( ConclusionNode ) node ).getControl();
            
            // If we land on the minimized node, we can start minimizing its children
            if ( _cpc == cpc )
            {
                children.add( node.getParent() );
                this.findChildrenOfConclusion( node, cpc, treeDepth, treeDepth, children );
                return;
            }
        }
        
        while( it.hasNext() )
        {
            getChildrenOfConclusionHelper( it.next(), cpc, treeDepth, children );
        }
        treeDepth -= 2; 
    }    

    private void findChildrenOfConclusion( ArgumentNode node, ConclusionPaneController cpc, 
                                           int treeDepth, int initialDepth, List<ArgumentNode> children )
    {
        children.add( node );
        
        ListIterator<ArgumentNode> it = node.getChildren().listIterator(); 
        
        if ( node instanceof ConclusionNode || node instanceof PremiseNode )
        {
            treeDepth++;
        }
        
        // Once we've returned/backtracked to the level we began minimizing at,
        // we are done minimizing the subtree [children].
        if ( treeDepth == initialDepth )
        {
            return;
        }
        
        while( it.hasNext() )
        {
            this.findChildrenOfConclusion( it.next(), cpc, treeDepth, initialDepth, children );
        }
        
        treeDepth -= 2;        
    }      
    
    /**
     * @param node
     * @param cpc
     * @param treeDepth
     * @param minimize 
     */
    private void minimizeTreeHelper( ArgumentNode node, ConclusionPaneController cpc, int treeDepth, boolean minimize )
    {
        ListIterator<ArgumentNode> it = node.getChildren().listIterator();
        
        if ( node instanceof ConclusionNode )
        {
            ConclusionPaneController _cpc = ( ( ConclusionNode ) node ).getControl();
            
            // If we land on the minimized node, we can start minimizing its children
            if ( _cpc == cpc )
            {
                this.recursivelyMinimize( node, treeDepth, treeDepth, minimize);
            }
        }
        
        while( it.hasNext() )
        {
            minimizeTreeHelper( it.next(), cpc, treeDepth, minimize);
        }
        treeDepth -= 2;        
    }    
    
    /**
     * @param node
     * @param ppc
     * @param treeDepth
     * @param minimize 
     */
    private void minimizeTreeHelper( ArgumentNode node, PremisePaneController ppc, int treeDepth, boolean minimize )
    {
        ListIterator<ArgumentNode> it = node.getChildren().listIterator();
        
        if ( node instanceof PremiseNode )
        {
            PremisePaneController _ppc = ( ( PremiseNode ) node ).getControl();
            
            // If we land on the minimized node, we can start minimizing its children
            if ( _ppc == ppc )
            {
                this.recursivelyMinimize( node, treeDepth, treeDepth, minimize);
            }
        }
        
        while( it.hasNext() )
        {
            minimizeTreeHelper( it.next(), ppc, treeDepth, minimize);
        }
        treeDepth -= 2;        
    }
        
    /**
     * @param node
     * @param treeDepth
     * @param initialDepth
     * @param minimize 
     */
    private void recursivelyMinimize( ArgumentNode node, int treeDepth, int initialDepth, boolean minimize )
    {
        // If we get to a node that isn't an 
        //  - ArgumentCertaintyNode, 
        //  - PremiseNexusNode,
        //  - CQIcon, or 
        //  - CQLabel,
        // we can use the algorithm to minimize it.
        if ( ! ( node instanceof ArgumentCertaintyNode    ) &&  
             ! ( node instanceof CQIcon                   ) &&
             ! ( node instanceof CQLabel                  ) &&
             ! ( node instanceof MultiArgConnectionNode   ) )
        {
                //
                // If we run into one of the two nexus nodes, we need to do something
                // different if it's a MultiArgPremiseNexusNode because it's the one
                // that actually has to be displayed and isn't used as an anchor
                //
                if ( node instanceof PremiseNexusNode && minimize )
                {
                    node.getView().setVisible( ( ( PremiseNexusNode ) node ).multiArg );
                } else 
                {
                   node.getView().setVisible( minimize );

                }
                
        }
        
        // If we are still on the first node ( the node we click to enable
        // or disable initial minimizing, we need to force visibility
        // so it isn't hidden from the user
        if ( treeDepth == initialDepth )
        {
            node.getView().setVisible( true );
        }
        
        ListIterator<ArgumentNode> it = node.getChildren().listIterator(); 
  
        // When we find a conclusion node or a premise node, we know that our
        // depth needs to increase because it actually indicates a level
        // lower in the tree
        if ( node instanceof ConclusionNode || node instanceof PremiseNode )
        {
            treeDepth++;
        }
        
        // Once we've returned/backtracked to the level we began minimizing at,
        // we are done minimizing the subtree [children].
        if ( treeDepth == initialDepth )
        {
            return;
        }
        while( it.hasNext() )
        {
            this.recursivelyMinimize( it.next(), treeDepth, initialDepth, minimize );
        }
        treeDepth -= 2;
    }
    
    /**
     * This method creates a text-representation of the current trees represented
     * in the construction area, and writes it to a file. 
     * 
     * The trees are recursively traversed,writing each tree at its corresponding 
     * level, then its children at subsequent (succeeding) levels (depths). If the 
     * tree hits a leaf child, it backtracks to find any higher children (if they exist). 
     * 
     * @param pw 
     */
    public void saveTree( PrintWriter pw ) 
    {
        int _level = 1;
        Stack<ArgNodeDepthPair> caFlagNodes = new Stack<>();
        this.saveTreeHelper( root, _level, pw, caFlagNodes );
        pw.println( "ENDTREE" );

    }
    
    /**
     * Algorithm to determine if the tree has any chains.
     * 
     * @param node
     * @return 
     */
    public boolean hasMultiArgChains( ArgumentNode node ) 
    {
        throw new UnsupportedOperationException( "Disabled as of 07/24/19 - chained arguments cannot be saved." );
    }
    
    /***
     * Counter arguments are disabled as of 7/24/19
     * @param node
     * @param treeDepth
     * @param fw
     * @param caFlagNodes 
     */
    private void saveTreeHelper( ArgumentNode node, int treeDepth, PrintWriter fw, Stack<ArgNodeDepthPair> caFlagNodes )
    {
        ListIterator<ArgumentNode> it = node.getChildren().listIterator();
        
        if ( node.caFlag )
        {
            caFlagNodes.push( new ArgNodeDepthPair( node, treeDepth ) );
        }        
        
        // Saving conclusion
        if( node instanceof ConclusionNode && ! ( node instanceof CounterPropositionNode ) 
                                           && ! ( node instanceof CounterArgumentNode ) 
                                           && ! ( node instanceof CQNode ) )
        {
            final ConclusionPaneController cpc = ( ( ConclusionNode ) node ).getControl();
            
            if( cpc == null ) { System.exit( 1 ); }
            
                final int                  x   = ( int ) node.getView().getLayoutX();
                final int                  y   = ( int ) node.getView().getLayoutY();
                
                /////////////////////////////
                //                         //
                //                         //
                //      SAVING TO FILE     //
                //                         //
                //                         //
                /////////////////////////////
                
                //  Saves current depth level in tree
                fw.println( this.repeat( "-", treeDepth ) + "level=" + treeDepth );         
                
                //  Saves type (premise, conclusion, etc)
                fw.println( this.repeat( "-", treeDepth ) + "type=" + "Conclusion" );       
                
                //  Saves the actual TITlE of the scheme
                fw.println( this.repeat( "-", treeDepth) + "title=" + cpc.getConclusionArgumentModel().getTitle() );

                //  Saves CQs
                fw.println( this.repeat( "-", treeDepth ) + "CQs=" + cpc.getConclusionArgumentModel().getCQs() );
                
                //  Saves proposition
                fw.println( this.repeat( "-", treeDepth ) + "proposition="
                                                          + cpc.getPropositionBoxController().getTextAreaText() );   
                
                //  Saves definition
                fw.println( this.repeat( "-", treeDepth ) + "definition="
                                                          + cpc.getProposition().getDefinition() );                   
                
                //  Saves positions
                fw.println( this.repeat( "-", treeDepth ) + "X=" + x );     
                fw.println( this.repeat( "-", treeDepth ) + "Y=" + y );
                fw.println( this.repeat( "-", treeDepth ) + "flags=" + ( cpc.getArgNode().caFlag ? 1 : 0 ) + " " +  cpc.getProCon()  );
                fw.println( this.repeat( "-", treeDepth ) + "END" );
		treeDepth++;
        }
        
        // Saving CQ
        else if( node instanceof CQNode )
        {
            final CQPaneController cqpc = ( CQPaneController )( ( CQNode ) node ).getControl();
            
            if ( cqpc == null ) { System.exit( 1 ); }
            
                final int               x   = ( int ) node.getView().getLayoutX();
                final int               y   = ( int ) node.getView().getLayoutY();
                
                /////////////////////////////
                //                         //
                //                         //
                //      SAVING TO FILE     //
                //                         //
                //                         //
                /////////////////////////////
                
                //  Saves current depth level in tree
                fw.println( this.repeat( "-", treeDepth ) + "level=" + treeDepth );         
                
                //  Saves type (premise, conclusion, etc)
                fw.println( this.repeat( "-", treeDepth ) + "type=" + "CQ" );       
                
                //  Saves proposition
                try
                {
                    fw.println( this.repeat( "-", treeDepth ) + "proposition="
                                                              + cqpc.getTextInTextArea() );   
                }                
                catch ( NullPointerException ex )
                {
                    AlertStage alert = new AlertStage( AlertType.WARNING, "Warning: Could not save diagram. Are all nodes active (did you click on every node)?",
                                                     ( Stage ) this.canvasControl.getMainPane().getScene().getWindow() );
                    fw.close();
                    throw new IllegalStateException( "Warning: Could not save diagram. Are all nodes active (did you click on every node)?" );
                }
                
                //  Saves positions
                fw.println( this.repeat( "-", treeDepth ) + "X=" + x );     
                fw.println( this.repeat( "-", treeDepth ) + "Y=" + y );
                fw.println( this.repeat( "-", treeDepth ) + "flags=" + 3 + " " + cqpc.getProCon() + " " + cqpc.getCQNum() );                
                fw.println( this.repeat( "-", treeDepth ) + "END" );
        }        
        
        // Saving Premise
        else if( node instanceof PremiseNode )
        {
            final PremisePaneController ppc = ( ( PremiseNode ) node ).getControl();
            
            if ( ppc == null ) { System.exit( 1 ); }
            
                final int               x   = ( int ) node.getView().getLayoutX();
                final int               y   = ( int ) node.getView().getLayoutY();
                
                /////////////////////////////
                //                         //
                //                         //
                //      SAVING TO FILE     //
                //                         //
                //                         //
                /////////////////////////////
                
                //  Saves current depth level in tree
                fw.println( this.repeat( "-", treeDepth ) + "level=" + treeDepth );         
                
                //  Saves type (premise, conclusion, etc)
                fw.println( this.repeat( "-", treeDepth ) + "type=" + "Premise" );       
                
                //  Saves proposition
                try
                {
                    fw.println( this.repeat( "-", treeDepth ) + "title="
                                                              +  ppc.getProposition().getTitle() );                    
                    
                    fw.println( this.repeat( "-", treeDepth ) + "proposition="
                                                              + ppc.getTextInTextArea() ); 
                    
                    fw.println( this.repeat( "-", treeDepth ) + "definition="
                                                              + ppc.getProposition().getDefinition() );
                }                
                catch ( NullPointerException ex )
                {
                    AlertStage alert = new AlertStage( AlertType.WARNING, 
                            "Warning: Could not save diagram. Are all nodes active (did you click on every node)?",
                            ( Stage ) this.canvasControl.getMainPane().getScene().getWindow() );
                    
                    fw.close();
                    throw new IllegalStateException( "Warning: Could not save diagram. Are all nodes active (did you click on every node)?" );
                }
                
                //  Saves positions
                fw.println( this.repeat( "-", treeDepth ) + "X=" + x );     
                fw.println( this.repeat( "-", treeDepth ) + "Y=" + y );
                fw.println( this.repeat( "-", treeDepth ) + "flags=" + ( ppc.getArgNode().caFlag ? 1 : 0 ) + " " + ppc.getProCon() );    
                System.out.println( "Premise proconflag: " + ppc.getProCon() );
                fw.println( this.repeat( "-", treeDepth ) + "END" );
        }
        
        while ( it.hasNext() )
        {
            this.saveTreeHelper( it.next(), treeDepth, fw, caFlagNodes );
        }
        
        treeDepth -= 2;
    }

    /**
     * Recursively erases all elements of this tree from the construction area
     *
     * @param node ArgumentNode currently being erased
     */
    private void eraseTree( ArgumentNode node )
    {
        this.canvas.getChildren().remove( node.getView() );

        ListIterator<ArgumentNode> it = node.getChildren().listIterator();
        while ( it.hasNext() )
        {
            this.eraseTree( it.next() );
        }
    }

    /**
     * Creates a new label
     *
     * @return
     */
    private Label createLabel()
    {
        Label lbl = new Label();
        lbl.setWrapText( true );
        lbl.setMaxWidth( 305 );
        lbl.setTextFill( Color.BLACK );
        lbl.setLayoutX( 10 );
        lbl.setLayoutY( 5 );
        lbl.setFont( new Font( "System Regular", 18 ) );
        return lbl;
    }

    // Methods for handling tree mergers such as adding sub arguments
    //--------------------------------------------------------------------------
    /**
     * Method for chaining arguments. Merges arguments by making one a
     * sub-argument of the other
     *
     * @param futureChildID String ID of the tree that will become a
     * sub-arguments
     * @param premiseControl point of merger in the "main" tree
     */
    public void mergeTree( String futureChildID, PremisePaneController premiseControl )
    {
        ArgumentViewTree mergedTree   = canvasControl.getArgTree( futureChildID );
        ArgumentNode     target       = searchForNode( root, premiseControl.getMainPane() );
        ArgumentNode     targetParent = target.getParent();
        ArgumentNode     chainNode    = null;
        mergedTree.deleteCommentPanes();
        deleteCommentPane( target );
        try
        {
            if ( premiseControl.getProposition() != null || mergedTree.getRoot().getControl().getProposition() != null )
            {
                if ( premiseControl.getProposition() != null && mergedTree.getRoot().getControl().getProposition() != null )
                {
                    if ( mergedTree.getRoot().getControl() instanceof MultiArgConclusionPaneController )
                    {
                        chainNode = createChainViewPremise( targetParent, mergedTree.getRoot().getControl(),
                                                               premiseControl );
                        System.out.println( "Choice1" );
                    } 
                    else 
                    {
                        chainNode = createChainViewPremise( targetParent, mergedTree.getRoot().getControl(),
                                                               premiseControl );
                    }
                } 
                else if ( premiseControl.getProposition() == null && mergedTree.getRoot().getControl().getProposition() != null )
                {
                    if ( mergedTree.getRoot().getControl() instanceof MultiArgConclusionPaneController )
                    {
                        chainNode = createMultiArgChainViewConclusion( targetParent, mergedTree.getRoot().getControl(),
                                                                       premiseControl );
                        System.out.println( "Choice5" );
                    } 
                    else
                    {
                        chainNode = createChainViewConclusion( targetParent, mergedTree.getRoot().getControl(),
                                                               premiseControl );
                        System.out.println( "Choice6" );
                    }
                } 
                else if ( premiseControl.getProposition() != null && mergedTree.getRoot().getControl().getProposition() == null )
                {
                    if ( mergedTree.getRoot().getControl() instanceof MultiArgConclusionPaneController )
                    {
                        chainNode = createMultiArgChainViewPremise( targetParent, mergedTree.getRoot().getControl(),
                                                                    premiseControl );
                        System.out.println( "Choice7" );
                    } 
                    else
                    {
                        chainNode = createChainViewPremise( targetParent, mergedTree.getRoot().getControl(),
                                                            premiseControl );
                        System.out.println( "Choice8" );
                    }
                }
                attachNewSubTree( chainNode, target, targetParent,
                                  mergedTree, futureChildID );
                canvasControl.removeArgumentTree( futureChildID );
            }
        } catch ( IOException ex )
        {
            Logger.getLogger( ArgumentViewTree.class.getName() ).log( Level.SEVERE, null, ex );
        }
    }

    /**
     * Method for chaining an argument to a counter proposition pane
     *
     * @param futureChildID
     * @param counterControl
     */
    public void mergeTree( String futureChildID, CounterPropositionPaneController counterControl )
    {
        ArgumentNode        target              = searchForNode( root, counterControl.getMainPane() );
        ArgumentNode        targetParent        = target.getParent();
        ArgumentViewTree    mergedTree          = canvasControl.getArgTree( futureChildID );
        ArgumentNode        counterArgumentNode = null;
        mergedTree.deleteCommentPanes();
        deleteCommentPane( target );
        
        try
        {
            if ( counterControl.getProposition() != null || mergedTree.getRoot().getControl().getProposition() != null )
            {
                if ( counterControl.getProposition() != null && mergedTree.getRoot().getControl().getProposition() != null )
                {
                    counterArgumentNode = createCounterArgumentViewConclusion( targetParent, mergedTree.getRoot().getControl(),
                                                                               counterControl );

                } 
                else if ( counterControl.getProposition() == null && mergedTree.getRoot().getControl().getProposition() != null )
                {
                    counterArgumentNode = createCounterArgumentViewConclusion( targetParent, mergedTree.getRoot().getControl(),
                                                                               counterControl );
                                                System.out.println( "Choice11" );

                } 
                else if ( counterControl.getProposition() != null && mergedTree.getRoot().getControl().getProposition() == null )
                {
                    counterArgumentNode = createCounterArgumentViewPremise( targetParent, mergedTree.getRoot().getControl(),
                                                                            counterControl);
                                                System.out.println( "Choice12" );

                }
                attachNewSubTree( counterArgumentNode, target, targetParent,
                                  mergedTree, futureChildID );
                canvasControl.removeArgumentTree( futureChildID );
                //collisionAdjustment();
                //canvasControl.constructionAreaSizeCheck();
            }
        } 
        catch ( IOException ex )
        {
            Logger.getLogger( ArgumentViewTree.class.getName() ).log( Level.SEVERE, null, ex );
        }
    }

    /**
     * Method for chaining arguments to a CQPane controller
     *
     * @param futureChildID
     * @param cqControl
     */
    public void mergeTree( String futureChildID, CQPaneController cqControl )
    {
        ArgumentNode     target       = searchForNode( root, cqControl.getMainPane() );
        ArgumentNode     targetParent = target.getParent();
        ArgumentViewTree mergedTree   = canvasControl.getArgTree( futureChildID );
        ArgumentNode     cqArgNode    = null;
        mergedTree.deleteCommentPanes();
        deleteCommentPane( target );
        
        try
        {
            if ( cqControl.getProposition() != null || mergedTree.getRoot().getControl().getProposition() != null )
            {
                if ( cqControl.getProposition() != null && mergedTree.getRoot().getControl().getProposition() != null )
                {
                    cqArgNode = createCQArgPaneConclusion( targetParent, mergedTree.getRoot().getControl(),
                                                           cqControl );

                } 
                else if ( cqControl.getProposition() == null && mergedTree.getRoot().getControl().getProposition() != null )
                {
                    cqArgNode = createCQArgPaneConclusion( targetParent, mergedTree.getRoot().getControl(),
                                                           cqControl );
                } 
                else if ( cqControl.getProposition() != null && mergedTree.getRoot().getControl().getProposition() == null )
                {
                    cqArgNode = createCQArgPanePremise( targetParent, mergedTree.getRoot().getControl(),
                                                        cqControl );
                }
                attachNewSubTree( cqArgNode, target, targetParent,
                                  mergedTree, futureChildID );
                canvasControl.removeArgumentTree( futureChildID );
                //collisionAdjustment();
                canvasControl.constructionAreaSizeCheck();
            }
        } catch ( IOException ex )
        {
            Logger.getLogger( ArgumentViewTree.class.getName() ).log( Level.SEVERE, null, ex );
        }
    }

    /**
     * Method for updating the nexus matrix of ArgumentViewTree when merging
     *
     * @param chainNode ArgumentNode the chain pane connecting the two arguments
     * @param mergedTree ArgumentViewTree argument tree being merged into this
     * one
     */
    private void updateNexusMatrix( ArgumentNode chainNode, ArgumentViewTree mergedTree )
    {
        ArgumentNode chainNodeControllingNexus = chainNode.getParent().getParent();
        ListIterator<List<ArgumentNode>> matrixIt = nexusMatrix.listIterator( 0 );
        List<ArgumentNode> targetLayer = null;
        while ( targetLayer == null && matrixIt.hasNext() )
        {
            List<ArgumentNode> inspectedLayer = matrixIt.next();
            for ( ArgumentNode nexus : inspectedLayer )
            {
                if ( nexus.equals( chainNodeControllingNexus ) )
                {
                    targetLayer = inspectedLayer;
                }
            }
        }
        Iterator<List<ArgumentNode>> mergedTreeIt = mergedTree.getNexusMatrix().iterator();

        while ( mergedTreeIt.hasNext() )
        {
            if (  ! matrixIt.hasNext() )
            {
                List<ArgumentNode> newLayer = new ArrayList<>();
                for ( ArgumentNode nexus : mergedTreeIt.next() )
                {
                    newLayer.add( nexus );
                }
                matrixIt.add( newLayer );
            } else
            {
                targetLayer = matrixIt.next();
                for ( ArgumentNode nexus : mergedTreeIt.next() )
                {
                    targetLayer.add( nexus );
                }
            }
        }
    }

    /**
     * Method for updating the pane matrix of ArgumentViewTree when merging
     *
     * @param replacedNode ArgumentNode being removed from the matrix
     * @param chainNode ArgumentNode the chain pane connecting the two arguments
     * @param mergedTree ArgumentViewTree argument tree being merged into this
     * one
     */
    private void updatePaneMatrix( ArgumentNode replacedNode, ArgumentNode chainNode, ArgumentViewTree mergedTree )
    {
        ListIterator<List<ArgumentNode>> matrixIt = paneMatrix.listIterator( 0 );
        List<ArgumentNode> targetLayer = null;
        while ( targetLayer == null && matrixIt.hasNext() )
        {
            List<ArgumentNode> inspectedLayer = matrixIt.next();
            for ( ArgumentNode pane : inspectedLayer )
            {
                if ( pane.equals( replacedNode ) )
                {
                    targetLayer = inspectedLayer;
                }
            }
        }
        targetLayer.remove( replacedNode );
        mergedTree.replaceInPaneMatrix( mergedTree.getRoot(), chainNode );
        Iterator<List<ArgumentNode>> mergedTreeIt = mergedTree.getPaneMatrix().iterator();
        while ( mergedTreeIt.hasNext() )
        {
            for ( ArgumentNode pane : mergedTreeIt.next() )
            {
                targetLayer.add( pane );
            }
            if ( mergedTreeIt.hasNext() )
            {
                if (  ! matrixIt.hasNext() )
                {
                    List<ArgumentNode> newLayer = new ArrayList<>();
                    matrixIt.add( newLayer );
                    targetLayer = matrixIt.previous();
                }
                targetLayer = matrixIt.next();
            }
        }
    }

    /**
     * Method for replacing an ArgumentNode in pane matrix with another
     *
     * @param replacee ArgumentNode to be replaced
     * @param replacement ArgumentNode replacing replacee
     */
    private void replaceInPaneMatrix(
            ArgumentNode replacee,
            ArgumentNode replacement
    )
    {
        List<ArgumentNode> targetLayer = null;
        ListIterator<List<ArgumentNode>> matrixIt = paneMatrix.listIterator( 0 );
        while ( targetLayer == null && matrixIt.hasNext() )
        {
            List<ArgumentNode> inspectedLayer = matrixIt.next();
            for ( ArgumentNode pane : inspectedLayer )
            {
                if ( pane.equals( replacee ) )
                {
                    targetLayer = inspectedLayer;
                }
            }
        }

        targetLayer.remove( replacee );
        targetLayer.add( replacement );
    }
    
    ////////////////////////////////////////////////////////////////////////////
    //                                                                        //
    //          METHODS FOR DETACHING SUBARGUMENTS AND CQ'S/COUNTER ARGS      //
    //                                                                        //
    ////////////////////////////////////////////////////////////////////////////
    /**
     * Method for detaching a sub argument
     *
     * @param chainControl ChainPaneController controller of the chain pane
     * acting as the conclusion of the sub argument being removed
     * @param coords Point2D coordinates where the new argument tree will be
     * drawn
     */
    public void detachArgumentChain( ChainPaneController chainControl, Point2D coords )
    {
        
        System.out.println( "detach 1" );
        try
        {
            /*
             * get reference to the chain node that is going to be split up and
             * its parent
             */
            ArgumentNode target            = searchForNode( root, chainControl.getMainPane() );
            ArgumentNode targetParent      = target.getParent();
            deleteCommentPane( target );

            List<ArgumentNode> targetLayer = findMatrixLayer( target, paneMatrix );
            /*
             * get the coordinates for where the new conclusion pane will be
             * drawn
             */
            Point2D targetCoords = new Point2D( target.getView().getLayoutX(),
                                                target.getView().getLayoutY() );

            /*
             * create the new premise node and splice it in place of the chain
             * node and draw it
             */
            ArgumentNode premiseBox = createPremiseView( chainControl.getPremiseArgument(),
                                                         targetParent.getView(),
                                                         chainControl.getPosition() );
            targetParent.removeChild( target );
            targetParent.addAsChild( premiseBox );
            premiseBox.setParent( targetParent );
            canvas.getChildren().add( premiseBox.getView() );

            ArgumentNode certaintyBox = createArgumentCertaintyBox( chainControl.getPremiseArgument(),
                                                                  ( PremiseNode ) premiseBox );
            premiseBox.addAsChild( certaintyBox );
            certaintyBox.setParent( premiseBox );
            canvas.getChildren().add( certaintyBox.getView() );

            //shrinkParentNexus( premiseBox );
            targetLayer.add( premiseBox );

            /*
             * create a new argument tree to contain the conclusion side of the
             * split
             */
            ArgumentViewTree newArgTree = new ArgumentViewTree( canvas, canvasControl );

            /*
             * make a new conclusion node and attached the branch containing the
             * conclusion side of the chain node to it and draw it
             */
            ConclusionNode newConclusion = createConclusionView( chainControl.getConclusionArgumentModel(),
                                                                 targetCoords );
            
            newConclusion.getControl().setCertaintyController( chainControl.getCertaintyController() );
            if ( chainControl.getProposition() != null )
            {
                newConclusion.getControl().addProposition( chainControl.getProposition() );
            }
            
            newConclusion.setArgTree( newArgTree );
            newArgTree.setRoot( newConclusion );
            ListIterator<ArgumentNode> targetChildren = target.getChildren().listIterator();
            
            while ( targetChildren.hasNext() )
            {
                ArgumentNode child = targetChildren.next();
                newConclusion.addAsChild( child );
                child.setParent( newConclusion );
                newArgTree.changeArgTree( child );
                targetChildren.remove();
            }
            canvas.getChildren().add( newConclusion.getView() );

            /*
             * shift the newly made argument tree so that it's offset from the
             * premise of the old tree
             */
            double transX = coords.getX() - target.getView().getLayoutX();
            double transY = coords.getY() - target.getView().getLayoutY();
            translateTree( newArgTree, transX, transY );
            removeNodeFromMatrix( paneMatrix, target );
            targetLayer.add( newConclusion );
            /*
             * clean up chain pane and register the new tree with the
             * cinstruction area
             */
            canvas.getChildren().remove( target.getView() );
            canvasControl.registerNewArgTree( newArgTree );

            updateAllCollisionMatricesOnDetach( newArgTree );
            //collisionAdjustment();
        } 
        catch ( IOException ex )
        {
            Logger.getLogger( ArgumentViewTree.class.getName() ).log( Level.SEVERE, null, ex );
        }
    }

    /**
     * Method for detaching a multiple arguments sharing the same conclusion
     * acting as a sub argument
     *
     * @param chainControl MultiArgChainPaneController controller of the pane
     * acting as the conclusion of the sub argument being removed
     * @param coords Point2D coordinates where the new argument tree will be
     * drawn
     */
    public void detachArgumentChain( MultiArgChainPaneController chainControl, Point2D coords )
    {
        System.out.println( "detach 2" );
        try
        {
            /*
             * get reference to the chain node that is going to be split up and
             * its parent
             */
            ArgumentNode target             = searchForNode( root, chainControl.getMainPane() );
            ArgumentNode targetParent       = target.getParent();
            deleteCommentPane( target );
            List<ArgumentNode> targetLayer  = findMatrixLayer( target, paneMatrix );
            /*
             * create the new premise node and splice it in place of the chain
             * node and draw it
             */
            ArgumentNode premiseBox = createPremiseView( chainControl.getPremiseArgument(),
                                                         targetParent.getView(), chainControl.getPosition() );
            targetParent.removeChild( target );
            targetParent.addAsChild( premiseBox );
            premiseBox.setParent( targetParent );
            canvas.getChildren().add( premiseBox.getView() );

            ArgumentNode certaintyBox = createArgumentCertaintyBox( chainControl.getPremiseArgument(),
                                                                  ( PremiseNode ) premiseBox );
            premiseBox.addAsChild( certaintyBox );
            certaintyBox.setParent( premiseBox );
            canvas.getChildren().add( certaintyBox.getView() );

            shrinkParentNexus( premiseBox );
            targetLayer.add( premiseBox );

            /*
             * create a new argument tree to contain the conclusion side of the
             * split
             */
            ArgumentViewTree newArgTree = new ArgumentViewTree( canvas, canvasControl );

            /*
             * make a new conclusion node and attached the branch containing the
             * conclusion side of the chain node to it and draw it
             */
            ConclusionNode newConclusion  = createNewMultiArgConclusion( target, chainControl );
            newConclusion.setArgTree( newArgTree );
            newArgTree.setRoot( newConclusion );
            ListIterator<ArgumentNode> targetChildren = target.getChildren().listIterator();
            while ( targetChildren.hasNext() )
            {
                ArgumentNode child = targetChildren.next();
                newConclusion.addAsChild( child );
                child.setParent( newConclusion );
                newArgTree.changeArgTree( child );
                targetChildren.remove();
            }
            canvas.getChildren().add( newConclusion.getView() );

            /*
             * shift the newly made argument tree so that it's offset from the
             * premise of the old tree
             */
            double transX = coords.getX() - target.getView().getLayoutX();
            double transY = coords.getY() - target.getView().getLayoutY();
            translateNode( newConclusion, transX, transY );

            removeNodeFromMatrix( paneMatrix, target );
            targetLayer.add( newConclusion );
            /*
             * clean up chain pane and register the new tree with the
             * cinstruction area
             */
            canvas.getChildren().remove( target.getView() );
            canvasControl.registerNewArgTree( newArgTree );
        } catch ( IOException ex )
        {
            Logger.getLogger( ArgumentViewTree.class.getName() ).log( Level.SEVERE, null, ex );
        }
    }

    /**
     * Method for detaching counter arguments from argument structures
     *
     * @param counterChainControl CounterArgumentPaneController controller of
     * the pane acting as the conclusion of the counter argument being removed
     * @param coords Point2D coordinates where the new ArgumentViewTree will be
     * drawn
     */
    public void detachArgumentChain( CounterArgumentPaneController counterChainControl, Point2D coords )
    {
        System.out.println( "detach 3" );
        try
        {
            /*
             * get reference to the chain node that is going to be split up and
             * its parent
             */
            ArgumentNode target            = searchForNode( root, counterChainControl.getMainPane() );
            ArgumentNode targetParent      = target.getParent();
            deleteCommentPane( target );

            List<ArgumentNode> targetLayer = findMatrixLayer( target, paneMatrix );
            /*
             * get the coordinates for where the new conclusion pane will be
             * drawn
             */
            Point2D targetCoords = new Point2D( target.getView().getLayoutX(), target.getView().getLayoutY() );

            /*
             * create the new counter premise node and splice it in place of the
             * chain node and draw it. Also replace the arguments in the
             * parent's counter arg list
             */
            CounterArgumentModel counterArg = new CounterArgumentModel();
            counterChainControl.addCounterArgumentToParentModels( counterArg );
            counterChainControl.removeCounterArgumentFromParentModels( counterChainControl.getArgument() );

            CounterPropositionNode counterPropBox = ( CounterPropositionNode ) createCounterPropositionView(
                                                                    counterChainControl.getParentModelList(),
                                                                    counterArg,
                                                                    targetParent, null );
            targetParent.removeChild( target );
            targetParent.addAsChild( counterPropBox );
            counterPropBox.setParent( targetParent );
            canvas.getChildren().add( counterPropBox.getView() );
            shrinkParentNexus( counterPropBox );
            targetLayer.add( counterPropBox );

            ArgumentNode certaintyBox = createArgumentCertaintyBox( counterArg.getConclusion(),
                                                     ( CounterPropositionNode ) counterPropBox );
            counterPropBox.addAsChild( certaintyBox );
            certaintyBox.setParent( counterPropBox );
            canvas.getChildren().add( certaintyBox.getView() );

             /*
             * create a new argument tree to contain the conclusion side of the
             * split
             */ 
             ArgumentViewTree newArgTree = new ArgumentViewTree( canvas, canvasControl );

            /*
             * make a new conclusion node and attached the branch containing the
             * conclusion side of the chain node to it and draw it
             */
            //convert counter argument to regular argument
            ArgumentModel newArg = new ArgumentModel( counterChainControl.getArgument() );
            ConclusionNode newConclusion = createConclusionView( newArg, targetCoords );
            newConclusion.getControl().setCertaintyController( counterChainControl.getCertaintyController() );
            if ( counterChainControl.getProposition() != null )
            {
                newConclusion.getControl().addProposition( counterChainControl.getProposition());
            }
            
            newConclusion.setArgTree( newArgTree );
            newArgTree.setRoot( newConclusion );
            ListIterator<ArgumentNode> targetChildren = target.getChildren().listIterator();
            
            while ( targetChildren.hasNext() )
            {
                ArgumentNode child = targetChildren.next();
                newConclusion.addAsChild( child );
                child.setParent( newConclusion );
                newArgTree.changeArgTree( child );
                targetChildren.remove();
            }
            canvas.getChildren().add( newConclusion.getView() );

            /*
             * shift the newly made argument tree so that it's offset from the
             * premise of the old tree
             */
            double transX = coords.getX() - target.getView().getLayoutX();
            double transY = coords.getY() - target.getView().getLayoutY();
            translateNode( newConclusion, transX, transY );

            removeNodeFromMatrix( paneMatrix, target );
            targetLayer.add( newConclusion );
            /*
             * clean up chain pane and register the new tree with the
             * cinstruction area
             */
            canvas.getChildren().remove( target.getView() );
            canvasControl.registerNewArgTree( newArgTree );

            shrinkCounterArgumentConnection( target );
            updateAllCollisionMatricesOnDetach( newArgTree );
            collisionAdjustment();
        } 
        catch ( IOException ex )
        {
            Logger.getLogger( ArgumentViewTree.class.getName() ).log( Level.SEVERE, null, ex );
        }
    }

    /**
     * Method for detaching critical question arguments from argument structures
     *
     * @param cqArgControl CQArgumentPaneController controller of the pane
     * acting as the conclusion of the counter argument being removed
     * @param coords Point2D coordinates where the new ArgumentViewTree will be
     * drawn
     */
    public void detachArgumentChain( CQArgumentPaneController cqArgControl, Point2D coords )
    {
        System.out.println( "detach 4" );
        try
        {
            /*
             * get reference to the chain node that is going to be split up and
             * its parent
             */
            ArgumentNode target = searchForNode( root, cqArgControl.getMainPane() );
            ArgumentNode targetParent = target.getParent();
            deleteCommentPane( target );

            List<ArgumentNode> targetLayer = findMatrixLayer( target, paneMatrix );
            /*
             * get the coordinates for where the new conclusion pane will be
             * drawn
             */
            Point2D targetCoords = new Point2D( target.getView().getLayoutX(),
                                                target.getView().getLayoutY() );

            /*
             * create the new CQ premise node and splice it in place of the
             * chain node and draw it. Also replace the arguments in the
             * parent's CQ arg list
             */
            ArgumentModel cqArg = new ArgumentModel();
            cqArgControl.addArgumentToParentCQArgList( cqArg );
            cqArgControl.removeArgumentFromParentCQArgList( cqArgControl.getArgument() );

            CQNode cqBox = ( CQNode ) createCQView( cqArg, cqArgControl.getParentArgument(),
                                                    targetParent );
            targetParent.removeChild( target );
            targetParent.addAsChild( cqBox );
            cqBox.setParent( targetParent );
            canvas.getChildren().add( cqBox.getView() );
            shrinkParentNexus( cqBox );
            targetLayer.add( cqBox );

            ArgumentNode certaintyBox = createArgumentCertaintyBox( cqArg.getConclusion(), cqBox );
            cqBox.addAsChild( certaintyBox );
            certaintyBox.setParent( cqBox );
            canvas.getChildren().add( certaintyBox.getView() );
            
            /*
             * create a new argument tree to contain the conclusion side of the
             * split
             */ ArgumentViewTree newArgTree = new ArgumentViewTree( canvas, canvasControl );

            /*
             * make a new conclusion node and attached the branch containing the
             * conclusion side of the chain node to it and draw it
             */
            ConclusionNode newConclusion = createConclusionView( cqArgControl.getArgument(),
                                                                 targetCoords );
            newConclusion.getControl().setCertaintyController( cqArgControl.getCertaintyController() );
            if ( cqArgControl.getProposition() != null )
            {
                newConclusion.getControl().addProposition( cqArgControl.getProposition() );
            }
            
            newConclusion.setArgTree( newArgTree );
            newArgTree.setRoot( newConclusion );
            ListIterator<ArgumentNode> targetChildren = target.getChildren().listIterator();
            while ( targetChildren.hasNext() )
            {
                ArgumentNode child = targetChildren.next();
                newConclusion.addAsChild( child );
                child.setParent( newConclusion );
                newArgTree.changeArgTree( child );
                targetChildren.remove();
            }
            
            canvas.getChildren().add( newConclusion.getView() );

            /*
             * shift the newly made argument tree so that it's offset from the
             * premise of the old tree
             */
            double transX = coords.getX() - target.getView().getLayoutX();
            double transY = coords.getY() - target.getView().getLayoutY();
            translateNode( newConclusion, transX, transY );

            removeNodeFromMatrix( paneMatrix, target );
            targetLayer.add( newConclusion );
            /*
             * clean up chain pane and register the new tree with the
             * cinstruction area
             */
            canvas.getChildren().remove( target.getView() );
            canvasControl.registerNewArgTree( newArgTree );

            updateAllCollisionMatricesOnDetach( newArgTree );
            collisionAdjustment();
        } catch ( IOException ex )
        {
            Logger.getLogger( ArgumentViewTree.class.getName() ).log( Level.SEVERE, null, ex );
        }
    }

    /**
     * recursively traverses up the tree and shrinks all nexus nodes it finds on
     * the way to root to their default value (determined by the number of
     * premises controlled by the nexus).
     *
     * @param node
     */
    private void shrinkParentNexus( ArgumentNode node )
    {
        // if a premise node is visited
        if ( node instanceof PremiseNexusNode )
        {
            /*
             * cast node to a nexus node and resize to original default size
             */
            PremiseNexusNode nexusNode = ( PremiseNexusNode ) node;
            double amountShrunk = resizeNexusToDefault( nexusNode );
            /*
             * shift node so that it is centered relative to its parent
             */
            nexusNode.getView().setLayoutX( ( int ) ( node.getView().getLayoutX() + ( amountShrunk / 2 ) ) );
            /*
             * reposition subtrees of nexus so that they are in the correct
             * relative positions
             */
            shiftNexusChildrenOnDetach( nexusNode );
        }
        if (  ! node.equals( root ) )
        {
            shrinkParentNexus( node.getParent() );
        }
    }

    /**
     * translates children of nexus nodes to their new positions on the nexus
     * after a nexus is shrunk on a detachment
     *
     * @param nexusNode PremiseNexusNode
     */
    private void shiftNexusChildrenOnDetach( PremiseNexusNode nexusNode )
    {
        //What the...
        int numChildren = nexusNode.getChildren().size();
        for ( int i = 0; i < numChildren; i ++ )
        {
            translateNode( nexusNode.getChildren().get( i ),( nexusNode.getView().getBoundsInParent().getMinX()
                         - nexusNode.getChildren().get( i ).getView().getBoundsInParent().getMinX() )
                         + ( i * ( PREMISE_WIDTH + PADDING ) ), ( nexusNode.getView().getBoundsInParent().getMaxY()
                         - nexusNode.getChildren().get( i ).getView().getBoundsInParent().getMinY() )
            );
        }
    }

    /**
     * resizes a nexus node to it's default size, determined by the number of
     * premises it controls. Returns the amount the nexus was shrunk
     *
     * @param nexus PremiseNexusNode
     *
     * @return double
     */
    private double resizeNexusToDefault( PremiseNexusNode nexus )
    {
        double currentWidth = nexus.getView().getBoundsInParent().getWidth();
        nexus.resizeToDefaultWidth();
        double defaultWidth = nexus.getView().getBoundsInParent().getWidth();
        return ( currentWidth - defaultWidth );
    }

    /**
     * method iterates through the layers of the specified matrices on the
     * detachment of argument subtree and transfers the nexus node references to
     * the new detached tree
     *
     * @param newTree newly created tree
     * @param parentMatrix tree that the new tree was detached from
     * @param newMatrix matrix of the new tree
     */
    private void updateMatrixOnDetach( ArgumentViewTree newTree, List<List<ArgumentNode>> parentMatrix,
                                       List<List<ArgumentNode>> newMatrix )
    {
        ListIterator<List<ArgumentNode>> newMatrixIt    = newMatrix.listIterator();
        ListIterator<List<ArgumentNode>> parentMatrixIt = parentMatrix.listIterator();

        while ( parentMatrixIt.hasNext() )
        {
            //create a new layer to possibly add to the new tree's nexus matrix
            List<ArgumentNode> newTreeNexusLayer            = new ArrayList<>();
            List<ArgumentNode> currentSearchLayer           = parentMatrixIt.next();
            ListIterator<ArgumentNode> currentSearchLayerIt = currentSearchLayer.listIterator();
            // iterate through a layer of the original matrix
            while ( currentSearchLayerIt.hasNext() )
            {
                ArgumentNode currentNode = currentSearchLayerIt.next();
                if ( newTree.containsNode( currentNode ) )
                {
                    /*
                     * if the new tree contains a nexus found in the old tree's
                     * matrix, add it to the layer created earlier and remove
                     * the reference to that node from the old matrix
                     */
                    newTreeNexusLayer.add( currentNode );
                    currentSearchLayerIt.remove();
                }
            }
            /*
             * if anything was added to the layer made earlier, add it as a
             * layer to the new tree's matrix
             */
            if (  ! newTreeNexusLayer.isEmpty() )
            {
                newMatrixIt.add( newTreeNexusLayer );
            }
            /*
             * if the layer we were looking at in the old matrix is now empty,
             * remove that layer
             */
            if ( currentSearchLayer.isEmpty() )
            {
                parentMatrixIt.remove();
            }
        }
    }

    //Adding critical questions to an argument structure
    //--------------------------------------------------------------------------
    public void addCriticalQuestion( ArgumentModel arg, ArgumentNode schemeLabel, int cqNum ) throws IOException
    {
        createNewCQStructure( arg, schemeLabel, cqNum );
        arg.setCQ( true );
    }
    
    /**
     * Instead of directly adding a new critical question by means of right clicking on the
     * argument scheme label and selecting one, loadCQ will instantiate a specific CQ
     * and proConFlag with the supplied proposition.
     * 
     * @param arg
     * @param schemeLabel
     * @param cqNum
     * @param proConFlag
     * @param proposition
     * @throws IOException 
     */
    public void loadCriticalQuestion( ArgumentModel arg, ArgumentNode schemeLabel, CQTuple tuple ) throws IOException
    {
        loadNewCQStructure( arg, schemeLabel, tuple );
        arg.setCQ( true );
    }    

    public void addAdditionalCriticalQuestion( ArgumentModel parentArg, ArgumentNode schemeLabel,
                                               int cqNum ) throws IOException
    {
        // get main connector
        CQConnectionNode mainConnector = null;
        for ( ArgumentNode child : schemeLabel.getParent().getChildren() )
        {
            if ( child instanceof CQConnectionNode )
            {
                mainConnector = ( CQConnectionNode ) child;
            }
        }

        //get nexus
        PremiseNexusNode nexus  = ( PremiseNexusNode ) findNextNexus( mainConnector );

        //create a connector for the new counter arg
        ArgumentNode specificCQConnector = createPremiseConnection( nexus.getView(), 0 );
        nexus.addAsChild( specificCQConnector );
        specificCQConnector.setParent( nexus );
        canvas.getChildren().add( specificCQConnector.getView() );

        // create new label for CQ
        ArgumentNode cqLabel = new CQLabel( parentArg.getPatchCriticalQuestion( cqNum ),
                                            getRelativeLayout( specificCQConnector.getView() ),
                                            this, canvas, specificCQConnector );
        
        cqLabel.setParent( specificCQConnector );
        specificCQConnector.addAsChild( cqLabel );
        canvas.getChildren().add( cqLabel.getView() );

        // create new CQ pane
        ArgumentModel newArg = new ArgumentModel();
        ArgumentNode cqPremise = createCQView( newArg, parentArg, specificCQConnector 
        );
        specificCQConnector.addAsChild( cqPremise );
        cqPremise.setParent( specificCQConnector );
        canvas.getChildren().add( cqPremise.getView() );

        ArgumentNode certaintyBox = createArgumentCertaintyBox( newArg.getConclusion(),
                                                              ( CQNode ) cqPremise );
        cqPremise.addAsChild( certaintyBox );
        certaintyBox.setParent( cqPremise );
        canvas.getChildren().add( certaintyBox.getView() );

        // adjust nexus size
        double amountShrunk = resizeNexusToDefault( nexus );
        /*
         * shift node so that it is centered relative to its parent
         */
        nexus.getView().setLayoutX( ( int ) ( nexus.getView().getLayoutX() + ( amountShrunk / 2 ) ) );
        /*
         * reposition subtrees of nexus so that they are in the correct relative
         * positions
         */
        shiftNexusChildrenOnDetach( nexus );
        /*
         * add new CQ pane to matrix
         */
        // add CQ pane
        List<ArgumentNode> targetLayer  = paneMatrix.get( paneMatrix.indexOf( findMatrixLayer(
                                                          schemeLabel.getParent(), paneMatrix ) ) + 1 );
        targetLayer.add( cqPremise );
        collisionAdjustment();
        canvasControl.constructionAreaSizeCheck();
    }

    private void createNewCQStructure( ArgumentModel parentArg, ArgumentNode schemeLabel, int cqNum ) throws IOException
    {
        ArgumentNode mainCQConnector = createCQConnection( parentArg, schemeLabel.getParent() );
        schemeLabel.getParent().addAsChild( mainCQConnector );
        mainCQConnector.setParent( schemeLabel.getParent() );
        canvas.getChildren().add( mainCQConnector.getView() );
              //  mainCQConnector.getView().setVisible( false );

        ArgumentNode cqIcon = createCQIcon( mainCQConnector );
        cqIcon.setParent( mainCQConnector );
        mainCQConnector.addAsChild( cqIcon );
        canvas.getChildren().add( cqIcon.getView() );
        cqIcon.getView().setVisible( false );

        ArgumentNode nexus = createNexus( 1, cqIcon.getView() );
        cqIcon.addAsChild( nexus );
        nexus.setParent( cqIcon );
        canvas.getChildren().add( nexus.getView() );
        nexus.getView().setVisible( false );

        /*
         * add new nexus to matrix
         */
        List<ArgumentNode> targetNexusLayer = nexusMatrix.get( nexusMatrix.indexOf( findMatrixLayer(
                                                                                    findNextNexus(
                                                                                    schemeLabel.getParent() ),
                                                                                    nexusMatrix ) ) );
        targetNexusLayer.add( nexus );

        ArgumentNode cqConnect = createCQPremiseConnection( mainCQConnector.getView() );
        nexus.addAsChild( cqConnect );
        cqConnect.setParent( nexus );
        canvas.getChildren().add( cqConnect.getView() );
        cqConnect.getView().toBack();

        ArgumentNode cqLabel = new CQLabel( parentArg.getPatchCriticalQuestion( cqNum ),
                                            getRelativeLayout( cqConnect.getView() ),
                                            this, canvas, cqConnect );
        cqLabel.setParent( cqConnect );
        cqConnect.addAsChild( cqLabel );
        canvas.getChildren().add( cqLabel.getView() );
        cqLabel.getView().setVisible( false );

        ArgumentModel newArg = new ArgumentModel();
        ArgumentNode cqPremise = createCQView( newArg, parentArg, cqConnect, ( PremiseConnectionNode ) cqConnect, cqNum );
        
        cqConnect.addAsChild( cqPremise );
        cqPremise.setParent( cqConnect );
        canvas.getChildren().add( cqPremise.getView() );

        ArgumentNode certaintyBox = createArgumentCertaintyBox( newArg.getConclusion(),
                                                              ( CQNode ) cqPremise );
        cqPremise.addAsChild( certaintyBox );
        certaintyBox.setParent( cqPremise );
        canvas.getChildren().add( certaintyBox.getView() );

        /*
         * add new CQ pane to matrix
         */
        // add CQ pane
        List<ArgumentNode> targetPaneLayer = paneMatrix.get( paneMatrix.indexOf(
                                                             findMatrixLayer( schemeLabel.getParent(), 
                                                             paneMatrix ) ) + 1 );
        targetPaneLayer.add( cqPremise );

        
        //collisionAdjustment();
        canvasControl.constructionAreaSizeCheck();
    }
    
    private void loadNewCQStructure( ArgumentModel parentArg, ArgumentNode schemeLabel, CQTuple tuple ) throws IOException
    {
        ArgumentNode mainCQConnector = createCQConnection( parentArg, schemeLabel.getParent() );
        schemeLabel.getParent().addAsChild( mainCQConnector );
        mainCQConnector.setParent( schemeLabel.getParent() );
        canvas.getChildren().add( mainCQConnector.getView() );
              //  mainCQConnector.getView().setVisible( false );

        ArgumentNode cqIcon = createCQIcon( mainCQConnector );
        cqIcon.setParent( mainCQConnector );
        mainCQConnector.addAsChild( cqIcon );
        canvas.getChildren().add( cqIcon.getView() );
        cqIcon.getView().setVisible( false );

        ArgumentNode nexus = createNexus( 1, cqIcon.getView() );
        cqIcon.addAsChild( nexus );
        nexus.setParent( cqIcon );
        canvas.getChildren().add( nexus.getView() );
        nexus.getView().setVisible( false );

        /*
         * add new nexus to matrix
         */
        List<ArgumentNode> targetNexusLayer = nexusMatrix.get( nexusMatrix.indexOf( findMatrixLayer(
                                                                                    findNextNexus(
                                                                                    schemeLabel.getParent() ),
                                                                                    nexusMatrix ) ) );
        targetNexusLayer.add( nexus );

        ArgumentNode cqConnect = createCQPremiseConnection( mainCQConnector.getView() );
        nexus.addAsChild( cqConnect );
        cqConnect.setParent( nexus );
        canvas.getChildren().add( cqConnect.getView() );
        cqConnect.getView().toBack();

        ArgumentNode cqLabel = new CQLabel( parentArg.getPatchCriticalQuestion( tuple.getCQNum() ),
                                            getRelativeLayout( cqConnect.getView() ),
                                            this, canvas, cqConnect );
        cqLabel.setParent( cqConnect );
        cqConnect.addAsChild( cqLabel );
        canvas.getChildren().add( cqLabel.getView() );
        cqLabel.getView().setVisible( false );

        ArgumentModel newArg = new ArgumentModel();
        ArgumentNode cqPremise = createCQView( newArg, parentArg, cqConnect, ( PremiseConnectionNode ) cqConnect, tuple.getCQNum() );
        
        cqConnect.addAsChild( cqPremise );
        cqPremise.setParent( cqConnect );
        canvas.getChildren().add( cqPremise.getView() );

        ArgumentNode certaintyBox = createArgumentCertaintyBox( newArg.getConclusion(),
                                                              ( CQNode ) cqPremise );
        cqPremise.addAsChild( certaintyBox );
        certaintyBox.setParent( cqPremise );
        canvas.getChildren().add( certaintyBox.getView() );

        /*
         * add new CQ pane to matrix
         */
        // add CQ pane
        List<ArgumentNode> targetPaneLayer = paneMatrix.get( paneMatrix.indexOf(
                                                             findMatrixLayer( schemeLabel.getParent(), 
                                                             paneMatrix ) ) + 1 );
        targetPaneLayer.add( cqPremise );

        CQPaneController cqpc = ( CQPaneController )( ( CQNode ) cqPremise ).getControl();
        
        cqpc.initializePane( tuple.getProposition(), tuple.getProConFlag() );
        
        //collisionAdjustment();
        canvasControl.constructionAreaSizeCheck();
    }    

    public void deleteCriticalQuestion( CQPaneController controller )
    {
        /*
         * get node reference to the CQ that is going to deleted
         */
        ArgumentNode target = searchForNode( root, controller.getMainPane() );
        deleteCommentPane( target );
        ArgumentNode targetConnector = target.getParent();
        ArgumentNode targetNexus = targetConnector.getParent();

        /*
         * remove pane and connector from structure
         */
        ListIterator<ArgumentNode> childIT = targetNexus.getChildren().listIterator();
        while ( childIT.hasNext() )
        {
            ArgumentNode child = childIT.next();
            if ( child.equals( targetConnector ) )
            {
                eraseTree( child );
                childIT.remove();
            }
        }
        eraseTree( targetConnector );
        removeSubTreeFromMatrices( target );

        /*
         * resize nexus to accomidate new number of children
         */
        //cast node to a nexus node and resize to original default size
        PremiseNexusNode nexusNode = ( PremiseNexusNode ) targetNexus;
        double amountShrunk = resizeNexusToDefault( nexusNode );
        
        //shift node so that it is centered relative to its parent
        nexusNode.getView().setLayoutX( ( int ) ( targetNexus.getView().getLayoutX() + ( amountShrunk / 2 ) ) );
        
        //reposition subtrees of nexus so that they are in the correct
        //relative positions
        //shiftNexusChildrenOnDetach( nexusNode );
        /*
         * check if we need to remove the counter argument structure i.e. if
         * there are no arguments left in the structure
         */
        if ( targetNexus.getChildren().isEmpty() )
        {
            // remove nexus
            canvas.getChildren().remove( targetNexus.getView() );
            //remove icon
            ArgumentNode cqIcon = targetNexus.getParent();
            canvas.getChildren().remove( cqIcon.getView() );
            //remove horizontal connector
            ArgumentNode horizontalIcon = cqIcon.getParent();
            canvas.getChildren().remove( horizontalIcon.getView() );
            //remove logical reference to the structure
            horizontalIcon.getParent().removeChild( horizontalIcon );
            // resent counter argument flag in parent argument
            controller.getParentArgument().setCQ( false );
        }
        //collisionAdjustment();
    }

    // Adding counter arguments to an argument structure
    //--------------------------------------------------------------------------
    public void addCounterArgument( List<PremiseModel> targetModelList, ArgumentNode parent ) throws IOException
    {
        if (  ! containsCounterArguments( targetModelList ) )
        {
            addCounterArgumentPane( targetModelList, parent );
        } else
        {
            addAdditionalCounterArg( targetModelList, parent );
        }
    }

    public void addCounterArgument( PremiseModel targetModel, ArgumentNode parent ) throws IOException
    {
        List<PremiseModel> targetModelList = new ArrayList<>();
        targetModelList.add( targetModel );
        parent.caFlag = true;
        if (  ! containsCounterArguments( targetModelList ) )
        {
            addCounterArgumentPane( targetModelList, parent );
        } 
        else
        {
            addAdditionalCounterArg( targetModelList, parent );
        }
    }

    private boolean containsCounterArguments( List<PremiseModel> modelList )
    {
        return modelList.stream().anyMatch((model) -> ( model.hasCounterArgument() ));
    }

    private void addAdditionalCounterArg( List<PremiseModel> parentModelList, ArgumentNode parent ) throws IOException
    {
        //find the counter arg connection
        CounterArgumentConnectionNode rootConnector = null;
        for ( ArgumentNode child : parent.getChildren() )
        {
            if ( child instanceof CounterArgumentConnectionNode )
            {
                rootConnector = ( CounterArgumentConnectionNode ) child;
            }
        }
        // get the matrix layer below the parent node
        List<ArgumentNode> targetMatrixLayer = paneMatrix.get( paneMatrix.indexOf(
                                               findMatrixLayer( parent, paneMatrix ) ) + 1 );
        //get nexus
        PremiseNexusNode nexus = ( PremiseNexusNode ) findNextNexus( rootConnector );

        //create a connector for the new counter arg
        ArgumentNode specificCounterConnector = createPremiseConnection( nexus.getView(), 0 );
        nexus.addAsChild( specificCounterConnector );
        specificCounterConnector.setParent( nexus );
        canvas.getChildren().add( specificCounterConnector.getView() );

        /*
         * create new argument model for counter argument and a new pane for
         * counter arg
         */
        CounterArgumentModel counterArg = new CounterArgumentModel();
        ArgumentNode counterPane = createCounterPropositionView( parentModelList,
                                                                 counterArg,
                                                                 specificCounterConnector, parent );
        specificCounterConnector.addAsChild( counterPane );
        counterPane.setParent( specificCounterConnector );
        canvas.getChildren().add( counterPane.getView() );
        //add counter argument to parent arg's counter argument list
        parentModelList.forEach((model) -> 
        {
            model.addCounterArgument( counterArg );
        });
        // add counter counter pane to matrix
        targetMatrixLayer.add( counterPane );

        ArgumentNode certaintyBox  = createArgumentCertaintyBox( counterArg.getConclusion(),
                                                     ( CounterPropositionNode ) counterPane );
        counterPane.addAsChild( certaintyBox );
        counterPane.caFlag = true;
        certaintyBox.setParent( counterPane );
        canvas.getChildren().add( certaintyBox.getView() );

        // adjust nexus size
        double amountShrunk = resizeNexusToDefault( nexus );
        
        /*
         * shift node so that it is centered relative to its parent
         */
        nexus.getView().setLayoutX( ( int ) ( nexus.getView().getLayoutX() + ( amountShrunk * 0.5 ) ) );
        
        /*
         * reposition subtrees of nexus so that they are in the correct relative
         * positions
         */
        shiftNexusChildrenOnDetach( nexus );

        collisionAdjustment();
        canvasControl.constructionAreaSizeCheck();
    }

    private void addCounterArgumentPane( List<PremiseModel> parentModelList, ArgumentNode parent ) throws IOException
    {
        ArgumentNode counterConnector = createCounterArgumentConnection( parent.getView() );
        parent.addAsChild( counterConnector );
        counterConnector.setParent( parent );
        canvas.getChildren().add( counterConnector.getView() );

        ArgumentNode counterIcon = createCounterIcon( counterConnector );
        counterIcon.setParent( counterConnector );
        counterConnector.addAsChild( counterIcon );
        canvas.getChildren().add( counterIcon.getView() );

        ArgumentNode counterSecondaryConnector = createPremiseConnection( counterIcon.getView(), 0, true );
        counterIcon.addAsChild( counterSecondaryConnector );
        counterSecondaryConnector.setParent( counterIcon );
        canvas.getChildren().add( counterSecondaryConnector.getView() );
        translateNode( counterSecondaryConnector, 60 - 3, 0 );

        ArgumentNode nexus = createNexus( 1, counterSecondaryConnector.getView() );
        counterSecondaryConnector.addAsChild( nexus );
        nexus.setParent( counterSecondaryConnector );
        canvas.getChildren().add( nexus.getView() );
        /*
         * add nexus to matrix
         */
        List<ArgumentNode> targetNexusLayer = findMatrixLayer( findNextNexus( parent ), nexusMatrix );
        targetNexusLayer.add( nexus );
        nexus.getView().setVisible( false );

        ArgumentNode specificCounterConnector = createPremiseConnection( nexus.getView(), 0, false );
        nexus.addAsChild( specificCounterConnector );
        specificCounterConnector.setParent( nexus );
        canvas.getChildren().add( specificCounterConnector.getView() );

        // create new argument model for counter argument
        CounterArgumentModel counterArg = new CounterArgumentModel();
        ArgumentNode counterPane = createCounterPropositionView( parentModelList, counterArg,
                                                                 specificCounterConnector, parent );
        specificCounterConnector.addAsChild( counterPane );
        counterPane.setParent( specificCounterConnector );
        canvas.getChildren().add( counterPane.getView() );
        
        //add counter argument to parent arg's counter argument list
        parentModelList.forEach( ( model ) -> 
        {
            model.addCounterArgument( counterArg );
        });

        ArgumentNode certaintyBox = createArgumentCertaintyBox( counterArg.getConclusion(),
                                                              ( CounterPropositionNode ) counterPane );
        counterPane.addAsChild( certaintyBox );
        certaintyBox.setParent( counterPane );
        canvas.getChildren().add( certaintyBox.getView() );

        updateNexusMatrix( parent, counterIcon, counterPane );
        //collisionAdjustment();
        canvasControl.constructionAreaSizeCheck();
    }

    public void deleteCounterArgument( CounterArgumentPaneController controller, List<PremiseModel> parentModelList,
                                       CounterArgumentModel counterArgument )
    {
        /*
         * get reference to the counter argument that is going to deleted
         */
        ArgumentNode target = searchForNode( root, controller.getMainPane() );
        target.caFlag = false;
        target.getParent().caFlag = false;
        deleteCommentPane( target );
        deleteCounterArgument( target, counterArgument, parentModelList );

    }

    public void deleteCounterArgument( CounterPropositionPaneController controller, List<PremiseModel> parentModelList,
                                       CounterArgumentModel counterArgument )
    {
        /*
         * get reference to the counter argument that is going to deleted
         */
        ArgumentNode target = searchForNode( root, controller.getMainPane() );
        target.caFlag = false;
        target.getParent().caFlag = false;
        deleteCommentPane( target );
        deleteCounterArgument( target, counterArgument, parentModelList );
    }

    private void deleteCounterArgument( ArgumentNode target, CounterArgumentModel counterArgument,
                                        List<PremiseModel> parentCounterArgumentList )
    {

        // Get connector nodes
        ArgumentNode targetConnector = target.getParent();
        ArgumentNode targetNexus = targetConnector.getParent();
        targetConnector.caFlag = false;
        target.caFlag = false;
        target.getParent().caFlag = false;
        deleteCommentPane( target );
        /*
         * remove pane and connector from structure
         */
        ListIterator<ArgumentNode> childIT = targetNexus.getChildren().listIterator();
        while ( childIT.hasNext() )
        {
            ArgumentNode child = childIT.next();
            if ( child.equals( targetConnector ) )
            {
                childIT.remove();
            }
        }
        eraseTree( targetConnector );
        removeSubTreeFromMatrices( target );

        // remove counter argument from parent counter arg list
        for ( PremiseModel parentModel : parentCounterArgumentList )
        {
            parentModel.getCounterArgumentList().remove( counterArgument );
        }

        /*
         * resize nexus to accomidate new number of children
         */
        //cast node to a nexus node and resize to original default size
        PremiseNexusNode nexusNode = ( PremiseNexusNode ) targetNexus;
        double amountShrunk = resizeNexusToDefault( nexusNode );
        //shift node so that it is centered relative to its parent
        nexusNode.getView().setLayoutX( ( int ) ( targetNexus.getView().getLayoutX() + ( amountShrunk / 2 ) ) );
        //reposition subtrees of nexus so that they are in the correct
        //relative positions
        shiftNexusChildrenOnDetach( nexusNode );

        /*
         * check if we need to remove the counter argument structure i.e. if
         * there are no arguments left in the structure
         */
        if ( targetNexus.getChildren().isEmpty() )
        {
            // undraw nexus
            canvas.getChildren().remove( targetNexus.getView() );
            removeNodeFromMatrix( nexusMatrix, targetNexus );
            //remove vertiacl connection
            ArgumentNode verticalConnector = targetNexus.getParent();
            canvas.getChildren().remove( verticalConnector.getView() );
            //remove icon
            ArgumentNode counterIcon = verticalConnector.getParent();
            canvas.getChildren().remove( counterIcon.getView() );
            removeNodeFromMatrix( paneMatrix, counterIcon );
            //remove horizontal connector
            ArgumentNode horizontalIcon = counterIcon.getParent();
            canvas.getChildren().remove( horizontalIcon.getView() );
            // shrink parent nexuses
            //shrinkParentNexus( horizontalIcon.getParent() );
            //remove logical reference to the structure
            horizontalIcon.getParent().removeChild( horizontalIcon );
        }
       // collisionAdjustment();
    }

    /**
     * Shrink the counter argument connection that counterPane is attached to
     * and shift over all related elements in the sub-tree to the new position
     *
     * @param counterPane ArgumentNode a counter argument pane
     */
    private void shrinkCounterArgumentConnection( ArgumentNode counterPane )
    {
        /*
         * cast node to a nexus node and resize to original default size
         */
        CounterArgumentConnectionNode counterConnection = 
                ( CounterArgumentConnectionNode ) findCounterConnection( counterPane);
        
        double amountShrunk = resizeCounterConnectionToDefault( counterConnection );

        /*
         * Reposition subtrees of nexus so that they are in the correct relative
         * positions
         */
        counterConnection.getChildren().forEach( ( child ) ->
        {
            translateNode( child, -amountShrunk, 0 );
        } );
    }

    /**
     * Resizes a counter connection to its default size
     *
     * @param counterConnection ArgumentNode
     *
     * @return double amount shrunk
     */
    private double resizeCounterConnectionToDefault( CounterArgumentConnectionNode counterConnection )
    {
        double currentWidth = counterConnection.getView().getBoundsInParent().getWidth();
        counterConnection.resizeToDefaultWidth();
        double defaultWidth = counterConnection.getView().getBoundsInParent().getWidth();
        return ( currentWidth - defaultWidth );
    }

    /**
     * Recurses up an argument tree to find the first ancestor that is an
     * instance of a CounterArgumentConnectionNode
     *
     * @param node ArgumentNode being inspected
     *
     * @return CounterArgumentConnectionNode
     */
    private CounterArgumentConnectionNode findCounterConnection( ArgumentNode node )
    {
        if ( node != null )
        {
            if ( node instanceof CounterArgumentConnectionNode )
            {
                return ( CounterArgumentConnectionNode ) node;
            }
            return findCounterConnection( node.getParent() );
        }
        return null;
    }

    // Methods for handeling Multiple arguments supporting the same conclusion
    //--------------------------------------------------------------------------
    public void createMultiArgBranch( String mergeTreeID, ConclusionPaneController mainTreeControl ) throws IOException
    {
        System.out.println( "is this called?" );
        int numPremises = 2;
        ArgumentViewTree mergedTree = canvasControl.getArgTree( mergeTreeID );
        mergedTree.deleteCommentPanes();
        ConclusionNode mergeTreeRoot = mergedTree.getRoot();
        if (  ! ( mergeTreeRoot.getControl() instanceof MultiArgConclusionPaneController ) )
        {
            // We need to reset the size of the controls so the original children
            // remain in the same place instead of being offset 
            mainTreeControl.resetSize();
            
            ConclusionNode mainConNode = ( ConclusionNode ) searchForNode( root, mainTreeControl.getMainPane() );

            ArgumentNode targetMatrix = findNextNexus( mainConNode );
            List<ArgumentNode> targetNexusMatrixLayer = findMatrixLayer( targetMatrix, nexusMatrix );
            List<ArgumentNode> targetPaneMatrixLayer = findMatrixLayer( mainConNode, paneMatrix );

            ConclusionNode newConclusion = createNewMultiArgConclusion( mainConNode, mainTreeControl,
                                                                        mergeTreeRoot.getControl() );

            root = newConclusion;

            ArgumentNode connector = createConclusionConnector( root.getView() );
            root.addAsChild( connector );
            connector.setParent( root );
            canvas.getChildren().add( connector.getView() );

            ArgumentNode label = createMultiArgLabel( root.getView() );
            root.addAsChild( label );
            label.setParent( root );
            canvas.getChildren().add( label.getView() );

            ArgumentNode nexus = createMultiArgPremiseNexus( numPremises, connector.getView() );
            connector.addAsChild( nexus );
            nexus.setParent( connector );
            canvas.getChildren().add( nexus.getView() );
            nexus.setArgTree( mergedTree );
            newConclusion.getControl().setPremiseNexus( ( PremiseNexusNode ) nexus );

            ArgumentNode multiArgPremiseConnect = createMultiArgPremiseConnection( nexus.getView(), 0 );
            nexus.addAsChild( multiArgPremiseConnect );
            multiArgPremiseConnect.setParent( nexus );
            canvas.getChildren().add( multiArgPremiseConnect.getView() );

            ArgumentNode multiArgSub = createMultiArgSubView( mainConNode.getControl().getConclusionArgumentModel(),
                                                              multiArgPremiseConnect.getView(),
                                                              mainConNode.getControl().getCertaintyController(), 0 );

            multiArgPremiseConnect.addAsChild( multiArgSub );
            multiArgSub.setParent( multiArgPremiseConnect );
            canvas.getChildren().add( multiArgSub.getView() );

            replaceConnectorWithMultiArgConnector( mainConNode, false );

            translateNode( mainConNode, multiArgSub.getView().getBoundsInParent().getMinX()
                    - mainConNode.getView().getBoundsInParent().getMinX()
                    - ( ( PREMISE_WIDTH - 40 ) / 2 ),
                    multiArgSub.getView().getBoundsInParent().getMinY()
                    - mainConNode.getView().getBoundsInParent().getMinY()
                    - ( PREMISE_HEIGHT + MULTI_ARG_Y_OFFSET ) );
            ListIterator<ArgumentNode> mainConChildrenIT = mainConNode.getChildren().listIterator();
            
            
            while ( mainConChildrenIT.hasNext() )
            {
                
                ArgumentNode child = mainConChildrenIT.next();

                multiArgSub.addAsChild( child );
                child.setParent( multiArgSub );
                mainConChildrenIT.remove();
            }
            for ( ArgumentNode node : multiArgSub.getChildren() )
            {
                if ( node instanceof ArgumentCertaintyNode )
                {
                    node.getView().setLayoutX( ( int ) ( node.getView().getLayoutX() - 85 ) );
                }
                
                // If we find a label, we need to shift it upwards
                // so it's not overlapping a pane
                if ( node instanceof CQConnectionNode )
                {
                    translateNode( node, 0, -30 );
                }
            }
            replaceInPaneMatrix( mainConNode, multiArgSub );

            ArgumentNode multiArgPremiseConnectB = createMultiArgPremiseConnection( nexus.getView(), 1 );
            nexus.addAsChild( multiArgPremiseConnectB );
            multiArgPremiseConnectB.setParent( nexus );
            canvas.getChildren().add( multiArgPremiseConnectB.getView() );

            ArgumentNode multiArgSubB = createMultiArgSubView(
                    mergeTreeRoot.getControl().getConclusionArgumentModel(),
                    multiArgPremiseConnectB.getView(),
                    mergeTreeRoot.getControl().getCertaintyController(),
                    1
            );

            replaceConnectorWithMultiArgConnector( mergeTreeRoot, false );

            multiArgPremiseConnectB.addAsChild( multiArgSubB );
            multiArgSubB.setParent( multiArgPremiseConnectB );
            canvas.getChildren().add( multiArgSubB.getView() );
            mergedTree.translateTree( multiArgSubB.getView().getBoundsInParent().getMinX() - ( ( PREMISE_WIDTH - 40 ) / 2 ),
                                      multiArgSubB.getView().getBoundsInParent().getMinY() - ( PREMISE_HEIGHT + MULTI_ARG_Y_OFFSET )  );
            ListIterator<ArgumentNode> mergeConChildrenIT = mergedTree.getRoot().getChildren().listIterator();
            while ( mergeConChildrenIT.hasNext() )
            {
                ArgumentNode child = mergeConChildrenIT.next();
                multiArgSubB.addAsChild( child );
                child.setParent( multiArgSubB );
                mergeConChildrenIT.remove();
            }
            for ( ArgumentNode node : multiArgSubB.getChildren() )
            {
                if ( node instanceof ArgumentCertaintyNode )
                {
                    node.getView().setLayoutX( ( int ) ( node.getView().getLayoutX() - 85 ) );
                }
                if ( node instanceof CQConnectionNode
                        || node instanceof ArgumentSchemeLabel )
                {
                    //translateNode( node, 0, 0 );
                }
            }
            mergedTree.replaceInPaneMatrix( mergedTree.getRoot(), multiArgSubB );

            changeArgTree( root );

            canvas.getChildren().add( newConclusion.getView() );
            canvas.getChildren().remove( mainConNode.getView() );

            canvasControl.removeArgumentTree( mergeTreeID );
            canvas.getChildren().remove( mergeTreeRoot.getView() );

            mergeMatrices( targetPaneMatrixLayer, paneMatrix, mergedTree.paneMatrix );
            mergeMatrices( targetNexusMatrixLayer, nexusMatrix, mergedTree.nexusMatrix );
            updateNexusMatrixShiftForward( nexus, paneMatrix );
            updateNexusMatrixShiftForward( nexus, nexusMatrix );
            targetPaneMatrixLayer.add( newConclusion );
            targetNexusMatrixLayer.add( nexus );
            mergeCounterArguments( newConclusion, multiArgSub, multiArgSubB );

            printMatrix( nexusMatrix );
            //collisionAdjustment();
            canvasControl.constructionAreaSizeCheck();
        }
    }

    /**
     * Method for merging the counter arguments of two structures when creating
     * a multiple arguments sharing the same conclusion structure
     *
     * @param parentNode
     * @param subA
     * @param subB
     *
     * @throws IOException
     */
    private void mergeCounterArguments( ConclusionNode parentNode, ArgumentNode subA, ArgumentNode subB ) throws IOException
    {
        ConclusionPaneController parentController = parentNode.getControl();
        List<ArgumentModel> argumentList          = parentController.getConclusionArgumentModelList();

        // gather counter arguments
        List<CounterArgumentModel> consolidatedCounterArguments = new ArrayList<>();
        for ( ArgumentModel argument : argumentList )
        {
            // temp reference to counter arg list for this conclusion
            List<CounterArgumentModel> currentCounterArguments = argument.getConclusion().getCounterArgumentList();
            //transfer over counter arguments to consolidated list
            for ( CounterArgumentModel counterArg : currentCounterArguments )
            {
                consolidatedCounterArguments.add( counterArg );
            }
            // clear this list. Will be populated later with consolidated list
            currentCounterArguments.clear();
        }

        if (  ! consolidatedCounterArguments.isEmpty() )
        {
            for ( ArgumentModel argument : argumentList )
            {
                // temp reference to counter arg list for this conclusion
                List<CounterArgumentModel> currentCounterArguments = argument.getConclusion().getCounterArgumentList();
                //copy consolidated list to current conclusion's counter list
                currentCounterArguments.addAll( consolidatedCounterArguments );
                //make sure that counter arguments have references to their
                //parent models
                for ( CounterArgumentModel counterArg : consolidatedCounterArguments )
                {
                    counterArg.addToParentModelList( argument.getConclusion() );
                }
            }
            /*
             * create new counter arg structure for the multi-arg structure
             */
            // create the connector for the coutner arg structure
            ArgumentNode counterConnector = createCounterArgumentConnection( parentNode.getView() );
            parentNode.addAsChild( counterConnector );
            counterConnector.setParent( parentNode );
            canvas.getChildren().add( counterConnector.getView() );

            // create shield icon
            ArgumentNode counterIcon = createCounterIcon( counterConnector );
            counterIcon.setParent( counterConnector );
            counterConnector.addAsChild( counterIcon );
            canvas.getChildren().add( counterIcon.getView() );
            // add new counter icon to matrix
            paneMatrix.get( paneMatrix.indexOf( findMatrixLayer( parentNode, paneMatrix ) ) ).add( counterIcon );

            // create the connector between the shield and the counter arg nexus
            ArgumentNode counterSecondaryConnector = createPremiseConnection( counterIcon.getView(), 0 );
            counterIcon.addAsChild( counterSecondaryConnector );
            counterSecondaryConnector.setParent( counterIcon );
            canvas.getChildren().add( counterSecondaryConnector.getView() );
            translateNode( counterSecondaryConnector, 60, 0 );

            // create counter arg nexus
            PremiseNexusNode nexus = ( PremiseNexusNode ) createNexus( 1, counterSecondaryConnector.getView() );
            counterSecondaryConnector.addAsChild( nexus );
            nexus.setParent( counterSecondaryConnector );
            canvas.getChildren().add( nexus.getView() );
            // add new nexus to matrix
            nexusMatrix .get( nexusMatrix.indexOf( findMatrixLayer( findNextNexus( parentNode ), nexusMatrix ) ) ) .add( nexus );

            int targetPaneLayerIndex = paneMatrix.indexOf( findMatrixLayer( parentNode, paneMatrix ) ) + 1;
            int targetNexusLayerIndex = nexusMatrix.indexOf( findMatrixLayer( findNextNexus( parentNode ), paneMatrix ) ) + 1;

            // find specific counter argument connections for mainConNode counters
            ArgumentNode counterConnectionNode = null;
            for ( ArgumentNode child : subA.getChildren() )
            {
                if ( child instanceof CounterArgumentConnectionNode )
                {
                    counterConnectionNode = child;
                }
            }
            if ( counterConnectionNode != null )
            {
                // remove counter icon from matrix
                removeNodeFromMatrix( paneMatrix, counterConnectionNode.getChildren().get( 0 ) );
                //remove nexus from matrix
                removeNodeFromMatrix( nexusMatrix, findNextNexus( counterConnectionNode ) );

                ListIterator<ArgumentNode> mainConSpecificCounterConnectors = findNextNexus( counterConnectionNode ).getChildren().listIterator();
                //translate counter arguments and reassign parents/children
                while ( mainConSpecificCounterConnectors.hasNext() )
                {
                    ArgumentNode connector = mainConSpecificCounterConnectors.next();

                    Point2D layout = getRelativeLayout( nexus.getView() );
                    Point2D adjustedLayout = new Point2D( layout.getX() - nexus.getView().getBoundsInParent().getWidth() / 2,
                                                          layout.getY() );
                    translateNode( connector, adjustedLayout.getX() - connector.getView().getLayoutX(), 
                                              adjustedLayout.getY() - connector.getView().getLayoutY() );

                    // reassigne relations
                    nexus.addAsChild( connector );
                    mainConSpecificCounterConnectors.remove();
                    connector.setParent( nexus );

                    // update matrix
                    shiftCounterArgumentInMatrix( paneMatrix, connector, targetPaneLayerIndex );
                    shiftCounterArgumentInMatrix( nexusMatrix, connector, targetNexusLayerIndex );

                    printMatrix( nexusMatrix );
                    // adjust nexus size
                    double amountShrunk = resizeNexusToDefault( nexus );
                    /*
                     * shift node so that it is centered relative to its parent
                     */
                    nexus.getView().setLayoutX( ( int ) ( nexus.getView().getLayoutX() + ( amountShrunk / 2 ) ) );
                    /*
                     * reposition subtrees of nexus so that they are in the
                     * correct relative positions
                     */
                    shiftNexusChildrenOnDetach( nexus );
                }
                //undraw old counter arg structures
                counterConnectionNode.getParent().removeChild( counterConnectionNode );
                counterConnectionNode.setParent( null );
                eraseTree( counterConnectionNode );
            }

            // find specific counter argument connections for mergeRoot counters
            ArgumentNode counterConnectionNode2 = null;
            for ( ArgumentNode child : subB.getChildren() )
            {
                if ( child instanceof CounterArgumentConnectionNode )
                {
                    counterConnectionNode2 = child;
                }
            }

            if ( counterConnectionNode2 != null )
            {
                // remove counter icon from matrix
                removeNodeFromMatrix( paneMatrix, counterConnectionNode2.getChildren().get( 0 ) );
                // remove nexus from matrix
                removeNodeFromMatrix( nexusMatrix, findNextNexus( counterConnectionNode2 ) );

                ListIterator<ArgumentNode> mergeRootSpecificCounterConnectors = findNextNexus( counterConnectionNode2 ).getChildren().listIterator();
                //translate counter arguments and reassign parents/children
                while ( mergeRootSpecificCounterConnectors.hasNext() )
                {
                    ArgumentNode connector = mergeRootSpecificCounterConnectors.next();

                    Point2D layout = getRelativeLayout( nexus.getView() );
                    Point2D adjustedLayout = new Point2D( layout.getX() - nexus.getView().getBoundsInParent().getWidth() / 2,
                                                          layout.getY() );
                    translateNode( connector, adjustedLayout.getX() - connector.getView().getLayoutX(),
                                              adjustedLayout.getY() - connector.getView().getLayoutY() );

                    // reassigne relations
                    nexus.addAsChild( connector );
                    mergeRootSpecificCounterConnectors.remove();
                    connector.setParent( nexus );

                    // update matrix
                    shiftCounterArgumentInMatrix( paneMatrix, connector, targetPaneLayerIndex );
                    shiftCounterArgumentInMatrix( nexusMatrix, connector, targetNexusLayerIndex );

                    // adjust nexus size
                    double amountShrunk = resizeNexusToDefault( nexus );
                    /*
                     * shift node so that it is centered relative to its parent
                     */
                    nexus.getView().setLayoutX( ( int ) ( nexus.getView().getLayoutX() + ( amountShrunk / 2 ) ) );
                    /*
                     * reposition subtrees of nexus so that they are in the
                     * correct relative positions
                     */
                    shiftNexusChildrenOnDetach( nexus );
                }
                //undraw old counter arg structures
                counterConnectionNode2.getParent().removeChild( counterConnectionNode2 );
                counterConnectionNode2.setParent( null );
                eraseTree( counterConnectionNode2 );
            }
            collisionAdjustment();
        }
    }

    private void shiftCounterArgumentInMatrix( List<List<ArgumentNode>> matrix, ArgumentNode subTreeRoot, int targetLayerIndex )
    {
        List<ArgumentNode> targetLayer = matrix.get( targetLayerIndex );
        ListIterator<List<ArgumentNode>> currentLayerIT = matrix.listIterator( targetLayerIndex + 1 );

        while ( currentLayerIT.hasNext() )
        {
            boolean swapOccured = false;
            List<ArgumentNode> currentLayer = currentLayerIT.next();
            ListIterator<ArgumentNode> currentNodeIT = currentLayer.listIterator();
            while ( currentNodeIT.hasNext() )
            {
                ArgumentNode currentNode = currentNodeIT.next();
                if ( containsNode( subTreeRoot, currentNode ) )
                {
                    currentNodeIT.remove();
                    targetLayer.add( currentNode );
                    swapOccured = true;
                }
            }

            if ( swapOccured )
            {
                targetLayerIndex ++;
                targetLayer = matrix.get( targetLayerIndex );
            }
        }

        if ( currentLayerIT.previous().isEmpty() )
        {
            currentLayerIT.remove();
        }
    }

    private void replaceConnectorWithMultiArgConnector( ArgumentNode conNode, boolean isChain )
    {
        ArgumentNode multiArgConnector = createMultiArgConnector( conNode.getView() );
        ArgumentNode mainConNexus = findNextNexus( conNode );
        ArgumentNode mainConConnector = mainConNexus.getParent();
        multiArgConnector.getView().setVisible( false );
        multiArgConnector.setParent( conNode );
        ListIterator<ArgumentNode> mainConConnectorIT = mainConConnector.getChildren().listIterator();
        while ( mainConConnectorIT.hasNext() )
        {
            
            ArgumentNode child = mainConConnectorIT.next();
            multiArgConnector.addAsChild( child );
            child.setParent( multiArgConnector );
            mainConConnectorIT.remove();
        }
        conNode.removeChild( mainConConnector );
        conNode.addAsChild( multiArgConnector );
        canvas.getChildren().remove( mainConConnector.getView() );
        canvas.getChildren().add( multiArgConnector.getView() );
        if ( !isChain )
        {
            translateNode( mainConNexus, 0, -37.5 );
        }
        else
        {
            translateNode( mainConNexus, 0, -140 );
        }
    }

    private ArgumentNode createMultiArgConnector( Node parentView )
    {
        Point2D layout = getRelativeLayout( parentView );
        MultiArgConnectionNode connector = new MultiArgConnectionNode( layout );

        return connector;
    }

    private void mergeMatrices( List<ArgumentNode> targetLayer, List<List<ArgumentNode>> targetNexus,
                                List<List<ArgumentNode>> mergeNexus )
    {
        ListIterator<List<ArgumentNode>> layerIT  = targetNexus.listIterator( targetNexus.indexOf( targetLayer ) );

        Iterator<List<ArgumentNode>> mergedTreeIt = mergeNexus.iterator();

        while ( mergedTreeIt.hasNext() )
        {
            if (  ! layerIT.hasNext() )
            {
                List<ArgumentNode> newLayer = new ArrayList<>();
                for ( ArgumentNode nexus : mergedTreeIt.next() )
                {
                    newLayer.add( nexus );
                }
                
                layerIT.add( newLayer );
            } 
            else
            {
                targetLayer = layerIT.next();
                for ( ArgumentNode nexus : mergedTreeIt.next() )
                {
                    targetLayer.add( nexus );
                }
            }
        }
    }

    private void updateNexusMatrixShiftForward( ArgumentNode parent, List<List<ArgumentNode>> matrix )
    {
        ListIterator<List<ArgumentNode>> layerIT = matrix.listIterator( matrix.size() );
        while ( layerIT.hasPrevious() )
        {
            List<ArgumentNode> tempList = new ArrayList<>();
            ListIterator<ArgumentNode> currentLayerIT = layerIT.previous().listIterator();
            while ( currentLayerIT.hasNext() )
            {
                ArgumentNode currentNode = currentLayerIT.next();
                if ( containsNode( parent, currentNode ) )
                {
                    tempList.add( currentNode );
                    currentLayerIT.remove();
                }
            }

            if (  ! tempList.isEmpty() )
            {
                layerIT.next();
                if (  ! layerIT.hasNext() )
                {
                    layerIT.add( tempList );
                } 
                else
                {
                    List<ArgumentNode> targetLayer = layerIT.next();
                    for ( ArgumentNode node : tempList )
                    {
                        targetLayer.add( node );
                    }
                }
                layerIT.previous();
                layerIT.previous();
            }
        }
    }

    public void detachMultiArgument( MultiArgSubConclusionPaneController subArgControl, Point2D coords )
    {
        try
        {
            /*
             * Get reference to the sub argument that is going to be split up
             * and its parent
             */
            ArgumentNode target = searchForNode( root, subArgControl.getMainPane() );
            ArgumentNode targetConnector = target.getParent();
            ArgumentNode targetNexus = targetConnector.getParent();
            deleteCommentPane( target );
            ConclusionNode targetSharedConclusion = ( ConclusionNode ) targetNexus.getParent().getParent();
            ConclusionPaneController targetConclusionControl = targetSharedConclusion.getControl();
            
            List<ArgumentNode> targetLayer = findMatrixLayer( target, paneMatrix );
            /*
             * Remove any shared counter arguments
             */
            List<CounterArgumentModel> counterArgs = subArgControl.getArgument().getConclusion().getCounterArgumentList();
            // remove conclusions model of argument being detached from any
            // counter arguments
            for ( CounterArgumentModel counter : counterArgs )
            {
                counter.removeFromParentModelList( subArgControl.getArgument().getConclusion() );
            }
            // remove any counter arguments
            subArgControl.getArgument().getConclusion().getCounterArgumentList().clear();

            /*
             * Get the coordinates for where the new conclusion pane will be
             * drawn
             */
            Point2D targetCoords = new Point2D( target.getView().getLayoutX() - 122, target.getView().getLayoutY() );

            /*
             * remove sub arg from nexus children and shared argument list
             */
            ListIterator<ArgumentNode> childIT = targetNexus.getChildren().listIterator();
            while ( childIT.hasNext() )
            {
                ArgumentNode child = childIT.next();
                if ( child.equals( targetConnector ) )
                {
                    childIT.remove();
                }
            }
            targetConclusionControl.removeArgument( subArgControl.getArgument() );
            canvas.getChildren().remove( target.getView() );
            canvas.getChildren().remove( targetConnector.getView() );
            removeNodeFromMatrix( paneMatrix, target );
            shrinkParentNexus( targetNexus );

            /*
             * create a new argument tree to contain the conclusion side of the
             * split
             */
            ArgumentViewTree newArgTree = new ArgumentViewTree( canvas, canvasControl );

            /*
             * make a new conclusion node and attached the branch containing the
             * conclusion side of the chain node to it and draw it
             */
            ConclusionNode newConclusion = createConclusionView( subArgControl.getArgument(), targetCoords );
            newConclusion.getControl().setCertaintyController( subArgControl.getCertaintyControl() );
            newConclusion.setArgTree( newArgTree );
            newConclusion.getControl().initializePane();
            newArgTree.setRoot( newConclusion );
            
            ArgumentNode newConclusionConnect = createConclusionConnector( newConclusion.getView() );
            ArgumentNode detachNexus = findNextNexus( target );
            ArgumentNode detachConConnector = detachNexus.getParent();
            newConclusionConnect.setParent( target );
            translateNode( target, 20, 0 );
            ListIterator<ArgumentNode> detachConConnectorIT = detachConConnector.getChildren().listIterator();
            while ( detachConConnectorIT.hasNext() )
            {
                ArgumentNode child = detachConConnectorIT.next();
                newConclusionConnect.addAsChild( child );
                child.setParent( newConclusionConnect );
                detachConConnectorIT.remove();
            }
            target.removeChild( detachConConnector );
            target.addAsChild( newConclusionConnect );
            canvas.getChildren().remove( detachConConnector.getView() );
            canvas.getChildren().add( newConclusionConnect.getView() );
            translateNode( detachNexus, 0, 250 );
            ListIterator<ArgumentNode> targetChildren = target.getChildren().listIterator();
            while ( targetChildren.hasNext() )
            {
                ArgumentNode child = targetChildren.next();
                newConclusion.addAsChild( child );
                child.setParent( newConclusion );
                newArgTree.changeArgTree( child );
                targetChildren.remove();
            }
            canvas.getChildren().add( newConclusion.getView() );

            /*
             * shift the newly made argument tree so that it's offset from the
             * premise of the old tree
             */
            double transX = coords.getX() - target.getView().getLayoutX();
            double transY = coords.getY() - target.getView().getLayoutY();
            translateNode( newConclusion, ( int ) transX, ( int ) transY );
            for ( ArgumentNode node : newConclusion.getChildren() )
            {
                if ( node instanceof ArgumentCertaintyNode )
                {
                    node.getView().setLayoutX( ( int ) ( node.getView().getLayoutX() + 85 ) );
                    node.getView().setLayoutY( ( int ) ( node.getView().getLayoutY() + 105 ) );
                }/*
                 * if (node instanceof ArgumentSchemeLabel) {
                 * node.getView().setLayoutY(node.getView().getLayoutY() + 95);
                 * }
                 */
                if ( node instanceof CQConnectionNode
                        || node instanceof ArgumentSchemeLabel )
                {
                    translateNode( node, 0, 215 );
                }
            }

            /*
             * clean up chain pane and register the new tree with the
             * cinstruction area
             */
            canvas.getChildren().remove( target.getView() );
            canvasControl.registerNewArgTree( newArgTree );

            /*
             * update the matrices and adjust tree to accomodate new dimensions
             */
            targetLayer.add( newConclusion );
            updateMatrixOnDetach( newArgTree, paneMatrix, newArgTree.getPaneMatrix() );
            updateMatrixOnDetach( newArgTree, nexusMatrix, newArgTree.getNexusMatrix() );
            //collisionAdjustment();

            /*
             * Check if we need to remove the shared conclusion structure i.e.
             * if there is only 1 argument left in the structure
             */
            if ( targetNexus.getChildren().size() == 1 )
            {
                ArgumentNode multiNode = targetNexus.getParent().getParent();
                if ( multiNode.equals( root ) )
                {
                    convertToSingleArgumentConclusion( root,
                            targetConclusionControl.getConclusionArgumentModel() );
                } 
                else
                {
                    if ( multiNode instanceof ChainNode )
                    {
                        convertToSingleArgumentChain( ( ChainNode ) multiNode );
                    }
                }
                //collisionAdjustment();
            }
        } 
        catch ( IOException ex )
        {
            Logger.getLogger( ArgumentViewTree.class
                    .getName() ).log( Level.SEVERE, null, ex );
        }
    }

    private void convertToSingleArgumentChain( ChainNode multiArgNode ) throws IOException
    {
        MultiArgSubNode subArgumentNode = ( MultiArgSubNode ) findNextSubArgument( multiArgNode );
        List<ArgumentNode> targetLayer  = findMatrixLayer( subArgumentNode, paneMatrix );
        /*
         * get the coordinates for where the new conclusion pane will be drawn
         */

        ChainNode newChain = createChainViewConclusion( multiArgNode.getParent(),
                                                        subArgumentNode, multiArgNode.getControl() );
        
        newChain.caFlag = multiArgNode.caFlag;

        newChain.setParent( multiArgNode.getParent() );
        multiArgNode.getParent().addAsChild( newChain );
        newChain.getParent().removeChild( multiArgNode );
        targetLayer.add( newChain );

        newChain.getControl().setCertaintyController( subArgumentNode.getControl().getCertaintyControl() );

        ArgumentNode newConclusionConnect = createConclusionConnector( subArgumentNode.getView() );

        ArgumentNode detachNexus  = findNextNexus( subArgumentNode );
        ArgumentNode detachConConnector = detachNexus.getParent();
        newConclusionConnect.setParent( subArgumentNode );

        ListIterator<ArgumentNode> detachConConnectorIT = detachConConnector.getChildren().listIterator();
        while ( detachConConnectorIT.hasNext() )
        {
            ArgumentNode child = detachConConnectorIT.next();
            newConclusionConnect.addAsChild( child );
            child.setParent( newConclusionConnect );
            detachConConnectorIT.remove();
        }
        subArgumentNode.removeChild( detachConConnector );
        subArgumentNode.addAsChild( newConclusionConnect );
        canvas.getChildren().remove( detachConConnector.getView() );
        canvas.getChildren().add( newConclusionConnect.getView() );

        //translateNode( detachNexus, 0, -205 );

        ListIterator<ArgumentNode> subArgumentChildren = subArgumentNode.getChildren().listIterator();
        while ( subArgumentChildren.hasNext() )
        {
            ArgumentNode child = subArgumentChildren.next();
            newChain.addAsChild( child );
            child.setParent( newChain );
            subArgumentChildren.remove();
        }

        double transY  = newChain.getView().getBoundsInParent().getMaxY()
                         - newConclusionConnect.getView().getBoundsInParent().getMinY();
        canvas.getChildren().add( newChain.getView() );
        removeNodeFromMatrix( paneMatrix, multiArgNode );
        removeNodeFromMatrix( paneMatrix, subArgumentNode );
        removeNodeFromMatrix( nexusMatrix, findNextNexus( multiArgNode ) );
        updateNexusMatrixShiftBack( paneMatrix, newChain );
        updateNexusMatrixShiftBack( nexusMatrix, newChain );

        ArgumentNode counterConnection = findChildCounterConnection( multiArgNode );
        if ( counterConnection != null )
        {
            newChain.addAsChild( counterConnection );
            counterConnection.getParent().removeChild( counterConnection );
            counterConnection.setParent( newChain );
        }

        undrawTree( multiArgNode );

        for ( ArgumentNode node : newChain.getChildren() )
        {
            //translateNode( node, 0, transY );
            if ( node instanceof ArgumentCertaintyNode )
            {
                node.getView().setLayoutX( ( int ) ( node.getView().getLayoutX() + 85 ) );
            }
            if ( node instanceof CQConnectionNode
                    || node instanceof ArgumentSchemeLabel )
            {
                translateNode( node, 0, 100 );
            }
            node.getView().toFront();
        }
        if ( counterConnection != null )
        {
            //translateNode( counterConnection, 0,  - transY );
        }
    }

    private void updateNexusMatrixShiftBack( List<List<ArgumentNode>> matrix, ArgumentNode parent )
    {
        ListIterator<List<ArgumentNode>> layerIT = matrix.listIterator();
        while ( layerIT.hasNext() )
        {
            List<ArgumentNode> tempList = new ArrayList<>();
            ListIterator<ArgumentNode> currentLayerIT = layerIT.next().listIterator();
            while ( currentLayerIT.hasNext() )
            {
                ArgumentNode currentNode = currentLayerIT.next();
                if ( containsNode( parent, currentNode ) )
                {
                    tempList.add( currentNode );
                    currentLayerIT.remove();
                }
            }

            if (  ! tempList.isEmpty() )
            {
                layerIT.previous();
                
                if (  ! layerIT.hasPrevious() )
                {
                    layerIT.add( tempList );
                } 
                else
                {
                    List<ArgumentNode> targetLayer = layerIT.previous();
                    for ( ArgumentNode node : tempList )
                    {
                        targetLayer.add( node );
                    }
                    
                    layerIT.next();
                }
                
                layerIT.next();
            }
        }

        List<ArgumentNode> finalLayer = layerIT.previous();
        if ( finalLayer.isEmpty() )
        {
            layerIT.remove();
        }
    }

    private ChainNode createChainViewConclusion( ArgumentNode parentNode, MultiArgSubNode subNode,
                                                 ChainPaneController multiControl ) throws IOException
    {
        ChainPaneController chainControl = generateChainNode();
        if ( multiControl.getCQFlag() )
        {
            chainControl.setCQFlag();
            chainControl.setConnector( multiControl.getConnector() );
        }
        
        if ( multiControl.getCounterFlag() )
        {
            chainControl.setCounterFlag();
            chainControl.setConnector( multiControl.getConnector() );
        }
        
        chainControl.addConclusionArgumentModel( multiControl.getConclusionArgumentModel() );
        chainControl.addPremiseArgument( multiControl.getPremiseArgument() );
        chainControl.setArgumentViewTree( this );
        chainControl.setParentControl( canvasControl );
        chainControl.setCertaintyController( subNode.getControl().getCertaintyControl() );
        chainControl.setPosition( multiControl.getPosition() );

        chainControl.setPropositionModel( multiControl.getConclusionArgumentModel().getConclusion().getProposition() );

        Point2D layout = getRelativeLayout( parentNode.getView() );
        Point2D adjustedLayout;
        if ( chainControl.getCQFlag() )
        {
            adjustedLayout  = new Point2D(
                            ( int ) layout.getX()
                            + chainControl.getConnector().getWidth()
                            - 163,
                            ( int ) layout.getY() + 15 );
            
        } 
        else if ( chainControl.getCounterFlag() )
        {
            adjustedLayout  = new Point2D(
                            ( int ) layout.getX()
                            + chainControl.getConnector().getWidth(),
                            ( int ) layout.getY() - 145 );
        } 
        else
        {
            adjustedLayout = new Point2D( ( int ) ( layout.getX() - PREMISE_WIDTH / 2 ),
                                          ( int ) layout.getY() );
        }

        LayoutUtils.setChildLayout( chainControl.getMainPane(), adjustedLayout );
        return new ChainNode( chainControl.getMainPane(), chainControl );
    }

    private boolean removeNodeFromMatrix( List<List<ArgumentNode>> matrix, ArgumentNode target )
    {
        ListIterator<List<ArgumentNode>> layerIT  = matrix.listIterator();
        boolean targetRemoved = false;
        while ( layerIT.hasNext() && targetRemoved == false )
        {
            List<ArgumentNode> currentLayer    = layerIT.next();
            ListIterator<ArgumentNode> nodeIT  = currentLayer.listIterator();
            
            while ( nodeIT.hasNext() && targetRemoved == false )
            {
                ArgumentNode currentNode = nodeIT.next();
                if ( currentNode.equals( target ) )
                {
                    nodeIT.remove();
                    targetRemoved = true;
                }
            }
        }
        
        return targetRemoved;
    }

    private void convertToSingleArgumentConclusion( ConclusionNode multiArgConNode, ArgumentModel argument ) throws IOException
    {
        MultiArgSubNode subArgumentNode = ( MultiArgSubNode ) findNextSubArgument( root );
        List<ArgumentNode> targetLayer  = findMatrixLayer( subArgumentNode, paneMatrix );

        /*
         * get the coordinates for where the new conclusion pane will be drawn
         */
        Point2D targetCoords = new Point2D( multiArgConNode.getView().getLayoutX(),
                                            multiArgConNode.getView().getLayoutY() );

        ConclusionNode newConclusion = createConclusionView( argument, targetCoords );
        newConclusion.caFlag = multiArgConNode.caFlag;
        targetLayer.add( newConclusion );
        newConclusion.getControl().setCertaintyController( subArgumentNode.getControl().getCertaintyControl() );

        ArgumentNode newConclusionConnect = createConclusionConnector( subArgumentNode.getView() );
        ArgumentNode detachNexus = findNextNexus( subArgumentNode );
        ArgumentNode detachConConnector = detachNexus.getParent();
        newConclusionConnect.setParent( subArgumentNode );

        ListIterator<ArgumentNode> detachConConnectorIT = detachConConnector.getChildren().listIterator();
        while ( detachConConnectorIT.hasNext() )
        {
            ArgumentNode child = detachConConnectorIT.next();
            newConclusionConnect.addAsChild( child );
            child.setParent( newConclusionConnect );
            detachConConnectorIT.remove();
        }
        subArgumentNode.removeChild( detachConConnector );
        subArgumentNode.addAsChild( newConclusionConnect );
        canvas.getChildren().remove( detachConConnector.getView() );
        canvas.getChildren().add( newConclusionConnect.getView() );
        translateNode( newConclusionConnect, 0, 95 );
        translateNode( detachNexus, 0, 145 );

        ListIterator<ArgumentNode> subArgumentChildren = subArgumentNode.getChildren().listIterator();
        while ( subArgumentChildren.hasNext() )
        {
            ArgumentNode child = subArgumentChildren.next();
            newConclusion.addAsChild( child );
            child.setParent( newConclusion );
            subArgumentChildren.remove();
        }

        double transY = targetCoords.getY() - subArgumentNode.getView().getBoundsInParent().getMinY();
        canvas.getChildren().add( newConclusion.getView() );

        removeNodeFromMatrix( paneMatrix, multiArgConNode );
        removeNodeFromMatrix( paneMatrix, subArgumentNode );
        removeNodeFromMatrix( nexusMatrix, findNextNexus( multiArgConNode ) );

        updateNexusMatrixShiftBack( paneMatrix, newConclusion );
        updateNexusMatrixShiftBack( nexusMatrix, newConclusion );

        ArgumentNode counterConnection = findChildCounterConnection( multiArgConNode );
        if ( counterConnection != null )
        {
            newConclusion.addAsChild( counterConnection );
            counterConnection.getParent().removeChild( counterConnection );
            counterConnection.setParent( newConclusion );
        }

        undrawTree( root );
        root = newConclusion;
        root.getControl().initializePane();

        for ( ArgumentNode node : newConclusion.getChildren() )
        {
            translateNode( node, 0, transY );
            if ( node instanceof ArgumentCertaintyNode )
            {
                node.getView().setLayoutX( ( int ) ( node.getView().getLayoutX() + 85 ) );
                node.getView().setLayoutY( ( int ) ( node.getView().getLayoutY() + 105 ) );
            }
            if ( node instanceof CQConnectionNode
                    || node instanceof ArgumentSchemeLabel )
            {
                translateNode( node, 0, 215 );
            }
        }
        if ( counterConnection != null )
        {
            translateNode( counterConnection, 0,  - transY );
        }
    }

    private ArgumentNode findChildCounterConnection( ArgumentNode target )
    {
        ArgumentNode result = null;
        for ( ArgumentNode child : target.getChildren() )
        {
            if ( child instanceof CounterArgumentConnectionNode )
            {
                result = child;
            }
        }
        return result;
    }

    private void undrawTree( ArgumentNode node )
    {
        canvas.getChildren().remove( node.getView() );
        for ( ArgumentNode child : node.getChildren() )
        {
            undrawTree( child );
        }
    }

    private ArgumentNode findNextSubArgument( ArgumentNode node )
    {
        if ( node instanceof MultiArgSubNode )
        {
            return node;
        }

        ArgumentNode target = null;
        for ( int i = 0; target == null && i < node.getChildren().size(); i ++ )
        {
            target = findNextSubArgument( node.getChildren().get( i ) );
        }

        return target;
    }

    public void addSupportToArgument( String mergedTreeID, MultiArgConclusionPaneController multiArgControl ) 
                                      throws IOException
    {
        ArgumentViewTree mergedTree = canvasControl.getArgTree( mergedTreeID );
        if ( mergedTree.getRoot().getControl() instanceof MultiArgConclusionPaneController )
        {
            addMultiConclusionSupport( mergedTree, multiArgControl );
        } 
        else
        {
            addSingleConclusionSupport( mergedTree, multiArgControl );
        }

    }

    public void addSupportToArgument( String mergedTreeID, MultiArgChainPaneController multiArgControl ) 
                                      throws IOException
    {
        ArgumentViewTree mergedTree = canvasControl.getArgTree( mergedTreeID );
        if ( mergedTree.getRoot().getControl() instanceof MultiArgConclusionPaneController )
        {
            addMultiConclusionSupport( mergedTree, multiArgControl );
        } 
        else
        {
            addSingleConclusionSupport( mergedTree, multiArgControl );
        }

    }

    private void addMultiConclusionSupport( ArgumentViewTree mergedTree, 
                                            MultiArgConclusionPaneController multiArgControl ) 
                                            throws IOException
    {
        ArgumentNode target = searchForNode( root, multiArgControl.getMainPane() );
        PremiseNexusNode targetNexus = ( PremiseNexusNode ) findNextNexus( target );
        // gets the nexus layer below the one containing the target nexus
        List<ArgumentNode> targetPaneMatrixLayer  = paneMatrix.get( paneMatrix.indexOf( 
                                                    findMatrixLayer( target, paneMatrix ) ) + 1 );
        List<ArgumentNode> targetNexusMatrixLayer = nexusMatrix.get( nexusMatrix.indexOf(
                                                    findMatrixLayer( findNextNexus( target ), nexusMatrix ) ) + 1 ); 
        ArgumentNode mergedRoot  = mergedTree.getRoot();
        ArgumentNode mergedNexus = findNextNexus( mergedRoot );

        List<MultiArgSubNode> mergeSubNodeList = new ArrayList<>();

        ListIterator<ArgumentNode> mergedNexusIT = mergedNexus.getChildren().listIterator();
        while ( mergedNexusIT.hasNext() )
        {
            ArgumentNode childNode = mergedNexusIT.next();
            MultiArgSubNode subNode = findNextSubArgNode( childNode );
            mergeSubNodeList.add( subNode );
            subNode.getControl().getArgument().setConclusion( multiArgControl.getProposition() );

            multiArgControl.addConclusionArgumentModel( subNode.getControl().getArgument() );

            targetNexus.addAsChild( childNode );
            childNode.setParent( targetNexus );
            mergedNexusIT.remove();

            double amountShrunk = resizeNexusToDefault( targetNexus );
            /*
             * shift node so that it is centered relative to its parent
             */
            targetNexus.getView().setLayoutX( ( int ) ( targetNexus.getView().getLayoutX() + ( amountShrunk / 2 ) ) );
            /*
             * reposition subtrees of nexus so that they are in the correct
             * relative positions
             */
            shiftNexusChildrenOnDetach( targetNexus );
        }

        /*
         * have to skip the first layer of the merged tree's nexus so that the
         * nexus controlling the supporting sup-arguments doesn't get copied
         */
        mergeMatrices( targetPaneMatrixLayer, paneMatrix,
                       mergedTree.paneMatrix.subList( 1, mergedTree.paneMatrix.size() ) );
        mergeMatrices( targetNexusMatrixLayer, nexusMatrix,
                       mergedTree.nexusMatrix.subList( 1, mergedTree.nexusMatrix.size() ) );

        mergeCounterArguments( target, mergedRoot, multiArgControl, mergeSubNodeList );

        changeArgTree( root );
        canvasControl.removeArgumentTree( mergedTree.getTreeID() );
        undrawTree( mergedRoot );
        collisionAdjustment();
        canvasControl.constructionAreaSizeCheck();
    }

    private void addMultiConclusionSupport( ArgumentViewTree mergedTree, 
                                            MultiArgChainPaneController multiArgControl ) 
                                            throws IOException
    {
        ArgumentNode target = searchForNode( root, multiArgControl.getMainPane() );
        PremiseNexusNode targetNexus = ( PremiseNexusNode ) findNextNexus( target );
        
        // Gets the nexus layer below the one containing the target nexus
        List<ArgumentNode> targetPaneMatrixLayer = paneMatrix.get( paneMatrix.indexOf(
                                                   findMatrixLayer( target, paneMatrix ) ) + 1 );
        
        List<ArgumentNode> targetNexusMatrixLayer = nexusMatrix.get( nexusMatrix.indexOf(
                                                    findMatrixLayer( findNextNexus( target ),
                                                    nexusMatrix ) ) + 1 );
        ArgumentNode mergedRoot  = mergedTree.getRoot();
        ArgumentNode mergedNexus = findNextNexus( mergedRoot );

        List<MultiArgSubNode> mergeSubNodeList = new ArrayList<>();

        ListIterator<ArgumentNode> mergedNexusIT = mergedNexus.getChildren().listIterator();
        while ( mergedNexusIT.hasNext() )
        {
            ArgumentNode childNode = mergedNexusIT.next();
            MultiArgSubNode subNode = findNextSubArgNode( childNode );
            mergeSubNodeList.add( subNode );
            subNode.getControl().getArgument().setConclusion( multiArgControl.getProposition() );

            multiArgControl.addConclusionArgumentModel( subNode.getControl().getArgument() );

            targetNexus.addAsChild( childNode );
            childNode.setParent( targetNexus );
            mergedNexusIT.remove();

            double amountShrunk = resizeNexusToDefault( targetNexus );
            /*
             * shift node so that it is centered relative to its parent
             */
            targetNexus.getView().setLayoutX( ( int ) ( targetNexus.getView().getLayoutX() + ( amountShrunk / 2 ) ) );
            /*
             * reposition subtrees of nexus so that they are in the correct
             * relative positions
             */
            shiftNexusChildrenOnDetach( targetNexus );
        }

        /*
         * have to skip the first layer of the merged tree's nexus so that the
         * nexus controlling the supporting sup-arguments doesn't get copied
         */
        mergeMatrices( targetPaneMatrixLayer, paneMatrix,
                       mergedTree.paneMatrix.subList( 1, mergedTree.paneMatrix.size() ) );
        mergeMatrices( targetNexusMatrixLayer, nexusMatrix,
                       mergedTree.nexusMatrix.subList( 1, mergedTree.nexusMatrix.size() ) );

        mergeCounterArguments( target, mergedRoot, multiArgControl, mergeSubNodeList );
        changeArgTree( root );
        canvasControl.removeArgumentTree( mergedTree.getTreeID() );
        undrawTree( mergedRoot );
        collisionAdjustment();
        canvasControl.constructionAreaSizeCheck();

    }

    private void mergeCounterArguments( ArgumentNode parentNode, ArgumentNode mergeNode,
                                        ConclusionPaneController parentController,
                                        List<MultiArgSubNode> subNodeList ) throws IOException
    {
        List<ArgumentModel> conclusionList   = parentController.getConclusionArgumentModelList();
        // all sub nodes should have identical counter argument lists, so we
        // only need to check the first one
        PremiseModel firstSubNodeConclusion  = subNodeList.get( 0 ).getControl()
                                             .getArgument().getConclusion();
        PremiseModel firstMultiArgConclusion = conclusionList.get( 0 ).getConclusion();
        PremiseNexusNode nexus = null;
        if ( firstMultiArgConclusion.hasCounterArgument() )
        {
            for ( ArgumentNode node : parentNode.getChildren() )
            {
                if ( node instanceof CounterArgumentConnectionNode )
                {
                    nexus = ( PremiseNexusNode ) findNextNexus( node );
                }
            }
        }
        if ( firstSubNodeConclusion.hasCounterArgument() )
        {
            // create counter argumnet structure if necessary
            // again, we only need to check the first counter arg list
            if (  ! firstMultiArgConclusion.hasCounterArgument() )
            {
                /*
                 * create new counter arg structure for the multi-arg structure
                 */
                // create the connector for the coutner arg structure
                ArgumentNode counterConnector = createCounterArgumentConnection( parentNode.getView() );
                parentNode.addAsChild( counterConnector );
                counterConnector.setParent( parentNode );
                canvas.getChildren().add( counterConnector.getView() );

                // create shield icon
                ArgumentNode counterIcon = createCounterIcon( counterConnector );
                counterIcon.setParent( counterConnector );
                counterConnector.addAsChild( counterIcon );
                canvas.getChildren().add( counterIcon.getView() );
                // add new counter icon to matrix
                paneMatrix.get( paneMatrix.indexOf( findMatrixLayer( parentNode, paneMatrix ) ) )
                                                   .add( counterIcon );

                // create the connector between the shield and the counter arg nexus
                ArgumentNode counterSecondaryConnector = createPremiseConnection( counterIcon.getView(), 0 );
                counterIcon.addAsChild( counterSecondaryConnector );
                counterSecondaryConnector.setParent( counterIcon );
                canvas.getChildren().add( counterSecondaryConnector.getView() );
                translateNode( counterSecondaryConnector, 60, 0 );

                // create counter arg nexus
                nexus = ( PremiseNexusNode ) createNexus( 1, counterSecondaryConnector.getView() );
                counterSecondaryConnector.addAsChild( nexus );
                nexus.setParent( counterSecondaryConnector );
                canvas.getChildren().add( nexus.getView() );
                nexusMatrix.get( nexusMatrix.indexOf( findMatrixLayer( findNextNexus( parentNode ),
                                                      nexusMatrix ) ) ) .add( nexus );
            } 
            else
            {
                // if the multiArg pane already has counter args, get reference 
                // to the nexus for them
                for ( ArgumentNode node : parentNode.getChildren() )
                {
                    if ( node instanceof CounterArgumentConnectionNode )
                    {
                        nexus = ( PremiseNexusNode ) findNextNexus( node );
                    }
                }
            }

            // find specific counter argument connections for mainConNode counters
            ArgumentNode counterConnectionNode = null;
            for ( ArgumentNode child : mergeNode.getChildren() )
            {
                if ( child instanceof CounterArgumentConnectionNode )
                {
                    counterConnectionNode = child;
                }
            }
            ListIterator<ArgumentNode> mainConSpecificCounterConnectors = findNextNexus
                                 ( counterConnectionNode ).getChildren().listIterator();
            //translate counter arguments and reassign parents/children
            while ( mainConSpecificCounterConnectors.hasNext() )
            {
                ArgumentNode connector = mainConSpecificCounterConnectors.next();

                Point2D layout = getRelativeLayout( nexus.getView() );
                Point2D adjustedLayout = new Point2D( layout.getX() - nexus.getView().getBoundsInParent().getWidth() / 2,
                                                      layout.getY() );
                translateNode( connector, adjustedLayout.getX() - connector.getView().getLayoutX(),
                                          adjustedLayout.getY() - connector.getView().getLayoutY() );

                // reassigne relations
                nexus.addAsChild( connector );
                mainConSpecificCounterConnectors.remove();
                connector.setParent( nexus );

                // update matrix
                //shiftCounterArgumentInMatrix(
                //connector, targetLayerIndex
                //);
                // adjust nexus size
                double amountShrunk = resizeNexusToDefault( nexus );
                /*
                 * shift node so that it is centered relative to its parent
                 */
                nexus.getView().setLayoutX( ( int ) ( nexus.getView().getLayoutX() + ( amountShrunk / 2 ) ) );
                /*
                 * reposition subtrees of nexus so that they are in the correct
                 * relative positions
                 */
                shiftNexusChildrenOnDetach( nexus );
            }
        }

        // gather counter arguments
        List<CounterArgumentModel> consolidatedCounterArguments = new ArrayList<>();
        // becuase all conclusions should have identical counter arg lists,
        // we only consolidate the counter args for the first conclusions.
        firstSubNodeConclusion.getCounterArgumentList().forEach( ( counterArg ) ->
        {
            consolidatedCounterArguments.add( counterArg );
        } );
        
        firstMultiArgConclusion.getCounterArgumentList().forEach( ( counterArg ) ->
        {
            consolidatedCounterArguments.add( counterArg );
        } );
        
        conclusionList.stream().map( ( conclusionArg ) ->
        {
            conclusionArg.getConclusion().getCounterArgumentList().clear();
            return conclusionArg;
            
        } ).forEachOrdered( ( conclusionArg ) ->
        {
            conclusionArg.getConclusion().getCounterArgumentList().addAll(
                    consolidatedCounterArguments
            );
        } );

        // walk through all counter panes and update the parent model list to
        // include all sub args
        if ( nexus != null )
        {
            for ( ArgumentNode child : nexus.getChildren() )
            {
                for ( ArgumentNode nexusChild : child.getChildren() )
                {
                    if ( nexusChild instanceof CounterArgumentNode )
                    {
                        List<PremiseModel> conModelList = new ArrayList<>();
                        for ( ArgumentModel conclusionArg : conclusionList )
                        {
                            conModelList.add( conclusionArg.getConclusion() );
                        }
                        ( ( CounterArgumentNode ) nexusChild ).getControl().setParentModelList( conModelList );
                    }
                    if ( nexusChild instanceof CounterPropositionNode )
                    {
                        List<PremiseModel> conModelList = new ArrayList<>();
                        for ( ArgumentModel conclusionArg : conclusionList )
                        {
                            conModelList.add( conclusionArg.getConclusion() );
                        }
                        ( ( CounterPropositionNode ) nexusChild ).getControl().setParentModelList( conModelList );
                    }
                }
            }
        }
        collisionAdjustment();
    }

    private void addSingleConclusionSupport( ArgumentViewTree mergedTree, MultiArgChainPaneController multiArgControl ) throws IOException
    {
        System.out.println( "calld 3" );
        ArgumentNode target = searchForNode( root, multiArgControl.getMainPane() );
        PremiseNexusNode targetNexus = ( PremiseNexusNode ) findNextNexus( target );
        // gets the nexus layer below the one containing the target nexus
        List<ArgumentNode> targetMatrixLayer  = paneMatrix.get( paneMatrix.indexOf( findMatrixLayer( target, paneMatrix ) ) + 1 );
        ArgumentNode mergedRoot = mergedTree.getRoot();
        ConclusionPaneController mergedControl = mergedTree.getRoot().getControl();
        ArgumentModel argument = mergedControl.getConclusionArgumentModel();

        argument.setConclusion( multiArgControl.getProposition() );
        multiArgControl.addConclusionArgumentModel( argument );
        int position = multiArgControl.getConclusionArgumentModelList().size() - 1;
        ArgumentNode connection = createMultiArgPremiseConnection( targetNexus.getView(), position );
        targetNexus.addAsChild( connection );
        connection.setParent( targetNexus );
        canvas.getChildren().add( connection.getView() );

        MultiArgSubNode subArgumentConclusion = ( MultiArgSubNode ) createMultiArgSubView( argument,
                                                  connection.getView(), mergedControl.getCertaintyController(), position );
        
        connection.addAsChild( subArgumentConclusion );
        subArgumentConclusion.setParent( connection );
        canvas.getChildren().add( subArgumentConclusion.getView() );

        replaceConnectorWithMultiArgConnector( mergedRoot, true );

        mergedTree.translateTree( subArgumentConclusion.getView().getBoundsInParent().getMinX()
                                  - ( ( PREMISE_WIDTH - 40 ) / 2 ), subArgumentConclusion.getView()
                                 .getBoundsInParent().getMinY() - ( PREMISE_HEIGHT - 40 ) );
        
        ListIterator<ArgumentNode> mergeConChildrenIT = mergedTree.getRoot().getChildren().listIterator();
        while ( mergeConChildrenIT.hasNext() )
        {
            ArgumentNode child = mergeConChildrenIT.next();
            subArgumentConclusion.addAsChild( child );
            child.setParent( subArgumentConclusion );
            mergeConChildrenIT.remove();
        }
        for ( ArgumentNode node : subArgumentConclusion.getChildren() )
        {
            if ( node instanceof ArgumentCertaintyNode )
            {
                node.getView().setLayoutX( ( int ) ( node.getView().getLayoutX() - 85 ) );
            }
            if ( node instanceof CQConnectionNode
                    || node instanceof ArgumentSchemeLabel )
            {
                translateNode( node, 0, -100 );
            }
        }
        mergedTree.replaceInPaneMatrix( mergedTree.getRoot(), subArgumentConclusion );
        changeArgTree( root );
        canvasControl.removeArgumentTree( mergedTree.getTreeID() );
        canvas.getChildren().remove( mergedRoot.getView() );

        double amountShrunk = resizeNexusToDefault( targetNexus );
        /*
         * shift node so that it is centered relative to its parent
         */
        targetNexus.getView().setLayoutX( ( int ) ( targetNexus.getView().getLayoutX()
                                        + ( amountShrunk / 2 ) ) );
        /*
         * reposition subtrees of nexus so that they are in the correct relative
         * positions
         */
        shiftNexusChildrenOnDetach( targetNexus );

        mergeMatrices( targetMatrixLayer, paneMatrix, mergedTree.paneMatrix );

        mergeCounterArguments( ( ConclusionNode ) target, subArgumentConclusion );

        //collisionAdjustment();

        //canvasControl.constructionAreaSizeCheck();
    }

    private MultiArgSubNode findNextSubArgNode( ArgumentNode node )
    {
        if ( node instanceof MultiArgSubNode )
        {
            return ( MultiArgSubNode ) node;
        }

        MultiArgSubNode target = null;
        for ( int i = 0; target == null && i < node.getChildren().size(); i ++ )
        {
            target = findNextSubArgNode( node.getChildren().get( i ) );
        }
        return target;
    }

    //THIS ONE IS BEING CALLED!
    private void addSingleConclusionSupport( ArgumentViewTree mergedTree, 
                                             MultiArgConclusionPaneController multiArgControl ) 
                                             throws IOException
    {
        System.out.println( "called 1" );
        ArgumentNode target = searchForNode( root, multiArgControl.getMainPane() );
        PremiseNexusNode targetNexus = ( PremiseNexusNode ) findNextNexus( target );
        // gets the nexus layer below the one containing the target nexus
        List<ArgumentNode> targetMatrixLayer = paneMatrix.get( paneMatrix.indexOf( findMatrixLayer( target, paneMatrix ) ) + 1 );
        ArgumentNode mergedRoot = mergedTree.getRoot();
        ConclusionPaneController mergedControl = mergedTree.getRoot().getControl();
        ArgumentModel argument = mergedControl.getConclusionArgumentModel();

        multiArgControl.addConclusionArgumentModel( argument );
        int position = multiArgControl.getConclusionArgumentModelList().size() - 1;
        ArgumentNode connection = createMultiArgPremiseConnection( targetNexus.getView(), position );
        targetNexus.addAsChild( connection );
        connection.setParent( targetNexus );
        canvas.getChildren().add( connection.getView() );

        MultiArgSubNode subArgumentConclusion = ( MultiArgSubNode ) createMultiArgSubView( argument,
                                                                    connection.getView(),
                                                                    mergedControl.getCertaintyController(),
                                                                    position );
        connection.addAsChild( subArgumentConclusion );
        subArgumentConclusion.setParent( connection );
        canvas.getChildren().add( subArgumentConclusion.getView() );

        replaceConnectorWithMultiArgConnector( mergedRoot, false );

        mergedTree.translateTree( subArgumentConclusion.getView().getBoundsInParent().getMinX()
                                                               - ( ( PREMISE_WIDTH - 40 ) / 2 ),
                                                                subArgumentConclusion.getView()
                                                                .getBoundsInParent()
                                                                .getMinY()
                                                               - ( PREMISE_HEIGHT + MULTI_ARG_Y_OFFSET ) );
        ListIterator<ArgumentNode> mergeConChildrenIT = mergedTree.getRoot().getChildren().listIterator();
        while ( mergeConChildrenIT.hasNext() )
        {
            ArgumentNode child = mergeConChildrenIT.next();
            subArgumentConclusion.addAsChild( child );
            child.setParent( subArgumentConclusion );
            mergeConChildrenIT.remove();
        }
        for ( ArgumentNode node : subArgumentConclusion.getChildren() )
        {
            if ( node instanceof ArgumentCertaintyNode )
            {
                node.getView().setLayoutX( ( int ) ( node.getView().getLayoutX() - 85 ) );
            }
            if ( node instanceof CQConnectionNode
                    || node instanceof ArgumentSchemeLabel )
            {
                //translateNode( node, 0, -100 );
            }
        }
        mergedTree.replaceInPaneMatrix( mergedTree.getRoot(), subArgumentConclusion );

        changeArgTree( root );
        canvasControl.removeArgumentTree( mergedTree.getTreeID() );
        canvas.getChildren().remove( mergedRoot.getView() );

        double amountShrunk = resizeNexusToDefault( targetNexus );
        /*
         * shift node so that it is centered relative to its parent
         */
        targetNexus.getView().setLayoutX( ( int ) ( targetNexus.getView().getLayoutX() + ( amountShrunk / 2 ) ) );
        /*
         * reposition subtrees of nexus so that they are in the correct relative
         * positions
         */
        shiftNexusChildrenOnDetach( targetNexus );

        mergeMatrices( targetMatrixLayer, paneMatrix, mergedTree.paneMatrix );

        mergeCounterArguments( ( ConclusionNode ) target, subArgumentConclusion );

        //collisionAdjustment();

        canvasControl.constructionAreaSizeCheck();
    }

    private void mergeCounterArguments( ConclusionNode parentNode, MultiArgSubNode subNode ) throws IOException
    {
        ConclusionPaneController parentController = parentNode.getControl();
        List<ArgumentModel> argumentList = parentController.getConclusionArgumentModelList();
        MultiArgSubConclusionPaneController subControl = subNode.getControl();

        if ( subControl.getArgument().getConclusion().hasCounterArgument() )
        {
            // gather counter arguments
            List<CounterArgumentModel> consolidatedCounterArguments = new ArrayList<>();
            argumentList.stream().map( ( conclusionModel ) -> conclusionModel.getConclusion()
                                                             .getCounterArgumentList() )
                                                             .forEachOrdered( ( currentCounterArguments ) ->
            {
                // Temp reference to counter arg list for this conclusion
                // transfer over counter arguments to consolidated list
                currentCounterArguments.forEach( ( counterArg ) ->
                {
                    consolidatedCounterArguments.add( counterArg );
                } );
            } );
            // create counter argumnet structure if necessary
            PremiseNexusNode nexus = null;
            ArgumentNode counterConnectionNode = null;
            for ( ArgumentNode child : parentNode.getChildren() )
            {
                if ( child instanceof CounterArgumentConnectionNode )
                {
                    counterConnectionNode = child;
                }
            }
            if ( counterConnectionNode == null )
            {
                /*
                 * create new counter arg structure for the multi-arg structure
                 */
                // create the connector for the coutner arg structure
                ArgumentNode counterConnector = createCounterArgumentConnection( parentNode.getView() );
                parentNode.addAsChild( counterConnector );
                counterConnector.setParent( parentNode );
                canvas.getChildren().add( counterConnector.getView() );

                // create shield icon
                ArgumentNode counterIcon = createCounterIcon( counterConnector );
                counterIcon.setParent( counterConnector );
                counterConnector.addAsChild( counterIcon );
                canvas.getChildren().add( counterIcon.getView() );
                // add new counter icon to matrix
                paneMatrix.get( paneMatrix.indexOf( findMatrixLayer( parentNode, paneMatrix ) ) ) .add( counterIcon );

                // create the connector between the shield and the counter arg nexus
                ArgumentNode counterSecondaryConnector = createPremiseConnection( counterIcon.getView(), 0 );
                counterIcon.addAsChild( counterSecondaryConnector );
                counterSecondaryConnector.setParent( counterIcon );
                canvas.getChildren().add( counterSecondaryConnector.getView() );
                translateNode( counterSecondaryConnector, 60, 0 );

                // create counter arg nexus
                nexus = ( PremiseNexusNode ) createNexus( 1, counterSecondaryConnector.getView() );
                counterSecondaryConnector.addAsChild( nexus );
                nexus.setParent( counterSecondaryConnector );
                canvas.getChildren().add( nexus.getView() );
            } 
            else
            {
                // if the multiArg pane already has counter args, get reference 
                // to the nexus for them
                for ( ArgumentNode node : parentNode.getChildren() )
                {
                    if ( node instanceof CounterArgumentConnectionNode )
                    {
                        nexus = ( PremiseNexusNode ) findNextNexus( node );
                    }
                }
            }

            int targetLayerIndex = paneMatrix.indexOf( findMatrixLayer( parentNode, paneMatrix ) ) + 1;
            int targetNexusLayerIndex = nexusMatrix.indexOf( findMatrixLayer( findNextNexus( parentNode ), paneMatrix ) ) + 1;

            // find specific counter argument connections for mainConNode counters
            ArgumentNode subCounterConnectionNode = null;
            for ( ArgumentNode child : subNode.getChildren() )
            {
                if ( child instanceof CounterArgumentConnectionNode )
                {
                    subCounterConnectionNode = child;
                }
            }
            if ( subCounterConnectionNode != null )
            {
                // remove counter icon from matrix
                removeNodeFromMatrix( paneMatrix, subCounterConnectionNode.getChildren().get( 0 ) );

                ListIterator<ArgumentNode> mainConSpecificCounterConnectors = findNextNexus( subCounterConnectionNode ).getChildren().listIterator();
                //translate counter arguments and reassign parents/children
                while ( mainConSpecificCounterConnectors.hasNext() )
                {
                    ArgumentNode connector = mainConSpecificCounterConnectors.next();

                    Point2D layout = getRelativeLayout( nexus.getView() );
                    Point2D adjustedLayout = new Point2D( layout.getX() - nexus.getView().getBoundsInParent().getWidth() / 2,
                                                          layout.getY() );
                    translateNode( connector, adjustedLayout.getX() - connector.getView().getLayoutX(),
                                              adjustedLayout.getY() - connector.getView().getLayoutY() );

                    // reassigne relations
                    nexus.addAsChild( connector );
                    mainConSpecificCounterConnectors.remove();
                    connector.setParent( nexus );

                    // update matrix
                    shiftCounterArgumentInMatrix( paneMatrix, connector, targetLayerIndex );
                    shiftCounterArgumentInMatrix( nexusMatrix, connector, targetNexusLayerIndex );
                    // adjust nexus size
                    double amountShrunk = resizeNexusToDefault( nexus );
                    /*
                     * shift node so that it is centered relative to its parent
                     */
                    nexus.getView().setLayoutX( ( int ) ( nexus.getView().getLayoutX() + ( amountShrunk / 2 ) ) );
                    /*
                     * reposition subtrees of nexus so that they are in the
                     * correct relative positions
                     */
                    shiftNexusChildrenOnDetach( nexus );
                }
                //undraw old counter arg structures
                subCounterConnectionNode.getParent().removeChild( subCounterConnectionNode );
                subCounterConnectionNode.setParent( null );
                eraseTree( subCounterConnectionNode );
            }
            // remove any duplicate values
            Set<CounterArgumentModel> disposal = new LinkedHashSet<>( consolidatedCounterArguments );
            consolidatedCounterArguments.clear();
            consolidatedCounterArguments.addAll( disposal );

            for ( ArgumentModel argument : argumentList )
            {
                // temp reference to counter arg list for this conclusion
                List<CounterArgumentModel> currentCounterArguments = argument.getConclusion().getCounterArgumentList();
                //copy consolidated list to current conclusion's counter list
                // clear this list. Will be populated later with consolidated list
                currentCounterArguments.clear();
                currentCounterArguments.addAll( consolidatedCounterArguments );
                //make sure that counter arguments have references to their
                //parent models
                for ( CounterArgumentModel counterArg : consolidatedCounterArguments )
                {
                    counterArg.addToParentModelList( argument.getConclusion() );
                }
            }
            collisionAdjustment();
        }
    }

    public void createMultiArgChain( String mergeTreeID, ChainPaneController chainControl ) throws IOException
    {
        System.out.println( "called 2" );
        int numPremises = 2;
        ArgumentViewTree mergedTree = canvasControl.getArgTree( mergeTreeID );
        ConclusionNode mergeTreeRoot = mergedTree.getRoot();
        mergedTree.deleteCommentPanes();
        if (  ! ( mergedTree.getRoot().getControl() instanceof MultiArgConclusionPaneController ) )
        {
            ChainNode chainNode = ( ChainNode ) searchForNode( root, chainControl.getMainPane() );
            ArgumentNode targetMatrix = findNextNexus( chainNode );
            List<ArgumentNode> targetNexusMatrixLayer = findMatrixLayer( targetMatrix, nexusMatrix );
            List<ArgumentNode> targetPaneMatrixLayer = findMatrixLayer( chainNode, paneMatrix );

            ChainNode multiChain = createMultiArgChainView( mergeTreeRoot.getControl(), chainControl );

            chainNode.getParent().addAsChild( multiChain );
            multiChain.setParent( chainNode.getParent() );
            multiChain.getParent().removeChild( chainNode );

            ArgumentNode connector = createConclusionConnector( multiChain.getView() );
            multiChain.addAsChild( connector );
            connector.setParent( multiChain );
            canvas.getChildren().add( connector.getView() );

            ArgumentNode label = createMultiArgLabel( multiChain.getView() );
            multiChain.addAsChild( label );
            label.setParent( multiChain );
            canvas.getChildren().add( label.getView() );

            ArgumentNode nexus = createMultiArgPremiseNexus( numPremises, connector.getView() );
            connector.addAsChild( nexus );
            nexus.setParent( connector );
            canvas.getChildren().add( nexus.getView() );

            ArgumentNode premiseConnect = createMultiArgPremiseConnection( nexus.getView(), 0 );
            nexus.addAsChild( premiseConnect );
            premiseConnect.setParent( nexus );
            canvas.getChildren().add( premiseConnect.getView() );

            ArgumentNode multiArgSub = createMultiArgSubView(
                    chainNode.getControl().getConclusionArgumentModel(),
                    premiseConnect.getView(),
                    chainNode.getControl().getCertaintyController(),
                    0
            );

            replaceConnectorWithMultiArgConnector( chainNode, true );

            premiseConnect.addAsChild( multiArgSub );
            multiArgSub.setParent( premiseConnect );
            canvas.getChildren().add( multiArgSub.getView() );
            translateNode( chainNode,
                    multiArgSub.getView().getBoundsInParent().getMinX()
                    - chainNode.getView().getBoundsInParent().getMinX()
                    - ( ( PREMISE_WIDTH - 40 ) / 2 ),
                    multiArgSub.getView().getBoundsInParent().getMinY()
                    - chainNode.getView().getBoundsInParent().getMinY()
                    - ( PREMISE_HEIGHT - 40 )
            );
            ListIterator<ArgumentNode> mainConChildrenIT
                    = chainNode.getChildren().listIterator();
            while ( mainConChildrenIT.hasNext() )
            {
                ArgumentNode child = mainConChildrenIT.next();
                multiArgSub.addAsChild( child );
                child.setParent( multiArgSub );
                mainConChildrenIT.remove();
            }
            for ( ArgumentNode node : multiArgSub.getChildren() )
            {
                if ( node instanceof ArgumentCertaintyNode )
                {
                    node.getView().setLayoutX( ( int ) ( node.getView().getLayoutX() - 85 ) );
                }
                if ( node instanceof CQConnectionNode
                        || node instanceof ArgumentSchemeLabel )
                {
                    translateNode( node, 0, -100 );
                }
            }
            replaceInPaneMatrix( chainNode, multiArgSub );

            ArgumentNode premiseConnectB = createMultiArgPremiseConnection( nexus.getView(), 1 );
            nexus.addAsChild( premiseConnectB );
            premiseConnectB.setParent( nexus );
            canvas.getChildren().add( premiseConnectB.getView() );

            ArgumentNode multiArgSubB = createMultiArgSubView(
                    mergeTreeRoot.getControl().getConclusionArgumentModel(),
                    premiseConnectB.getView(),
                    mergeTreeRoot.getControl().getCertaintyController(),
                    1
            );

            replaceConnectorWithMultiArgConnector( mergedTree.getRoot(), true );

            premiseConnectB.addAsChild( multiArgSubB );
            multiArgSubB.setParent( premiseConnectB );
            canvas.getChildren().add( multiArgSubB.getView() );
            mergedTree.translateTree( multiArgSubB.getView().getBoundsInParent().getMinX()
                    - ( ( PREMISE_WIDTH - 40 ) / 2 ),
                    multiArgSubB.getView().getBoundsInParent().getMinY()
                    - ( PREMISE_HEIGHT - 40 )
            );
            ListIterator<ArgumentNode> mergeConChildrenIT = mergedTree.getRoot().getChildren().listIterator();
            while ( mergeConChildrenIT.hasNext() )
            {
                ArgumentNode child = mergeConChildrenIT.next();
                multiArgSubB.addAsChild( child );
                child.setParent( multiArgSubB );
                mergeConChildrenIT.remove();
            }
            for ( ArgumentNode node : multiArgSubB.getChildren() )
            {
                if ( node instanceof ArgumentCertaintyNode )
                {
                    node.getView().setLayoutX( ( int ) ( node.getView().getLayoutX() - 85 ) );
                }
                if ( node instanceof CQConnectionNode
                        || node instanceof ArgumentSchemeLabel )
                {
                    translateNode( node, 0, -100 );
                }
            }
            mergedTree.replaceInPaneMatrix( mergedTree.getRoot(), multiArgSubB );
            changeArgTree( root );
            
            translateTree( mergedTree, 200, 100 );

            canvas.getChildren().add( multiChain.getView() );
            canvas.getChildren().remove( chainNode.getView() );

            canvasControl.removeArgumentTree( mergeTreeID );
            canvas.getChildren().remove( mergeTreeRoot.getView() );

            mergeMatrices( targetPaneMatrixLayer, paneMatrix, mergedTree.paneMatrix );
            mergeMatrices( targetNexusMatrixLayer, nexusMatrix, mergedTree.nexusMatrix );
            updateNexusMatrixShiftForward( nexus, paneMatrix );
            updateNexusMatrixShiftForward( nexus, nexusMatrix );
            targetPaneMatrixLayer.add( multiChain );
            targetNexusMatrixLayer.add( nexus );

            mergeCounterArguments( multiChain, multiArgSub, multiArgSubB );

            Line chainLine = ( Line ) chainControl.getConnectionNode().getView();
            
            Pane maCPC = multiChain.getControl().getMainPane();
            
            Bounds cpcBounds = maCPC.localToScreen( maCPC.getBoundsInLocal() );
            
            chainLine.setEndX( cpcBounds.getMinX() + PREMISE_WIDTH / 2 );
            chainLine.setEndY( cpcBounds.getMinY() );
            
           // collisionAdjustment();
        }
    }

    // Collision detection and matrix operations
    //--------------------------------------------------------------------------
    /**
     * method checks the pane and nexus nodes of the argument tree. If there is
     * overlap between pane nodes on the same level, this method recurses up the
     * tree to find their shared link and grows the appropriate connector to
     * remove the overlap. It then shifts tree elements in order to their new
     * positions. If a change is made, this method is called again because any
     * changes might cause collisions with other panes(like bubble-sort).
     */
    private void collisionAdjustment()
    {
        //boolean paneMatrixAdjusted = paneMatrixAdjustment();
        /*
         * recheck tree to see if further adjustments need to be made as a
         * result of other changes
         */
//        if ( paneMatrixAdjusted )
//        {
//            //collisionAdjustment();
//        } else
//        {
            nexusMatrixAdjustment();
       // }
    }

    /**
     * Method checks the pane nodes of the argument tree. If there is overlap
     * between pane nodes on the same level, the youngest common ancestor of the
     * colliding nodes is found and the tree structure is adjusted to create the
     * necessary space
     *
     * @return boolean True if any adjustments are made
     */
    private boolean paneMatrixAdjustment()
    {
        boolean adjustmentMade = false;
        for ( List<ArgumentNode> paneLayer : paneMatrix )
        {
            for ( ArgumentNode targetPane : paneLayer )
            {
                /*
                 * compare the positions of each pane in a layer to every other
                 * pane in the layer.
                 */
                for ( ArgumentNode comparePane : paneLayer )
                {
                    /*
                     * avoid comparingthe dimensions of a pane to itself
                     */
                    if (  ! targetPane.equals( comparePane ) )
                    {
                        double overlap = detectPaneOverlap( targetPane, comparePane );
                        /*
                         * if there is not enought space between the panes, grow
                         * their shared ancestor (nexus or connector)
                         */
                        if ( overlap > 0 )
                        {
                            // find linking Node
                            ArgumentNode linkingNode = findLinkingNode( targetPane, comparePane );
                            
                            if ( linkingNode instanceof PremiseNexusNode )
                            {
                                premiseNexusCollision( ( PremiseNexusNode ) linkingNode, ( int ) overlap );
                            } 
                            else
                            {
                                otherCollision( linkingNode, targetPane, comparePane, overlap );
                            }
                            // note that an adjustment was made
                            adjustmentMade = true;
                        }
                    }
                }
            }
        }
        return adjustmentMade;
    }

    /**
     * Method checks the nexus nodes of the argument tree. If there is overlap
     * between pane nodes on the same level, the youngest common ancestor of the
     * colliding nodes is found and the tree structure is adjusted to create the
     * necessary space
     *
     * @return boolean True if any adjustments are made
     */
    protected void nexusMatrixAdjustment()
    {
        boolean adjustmentMade = false;
        for ( List<ArgumentNode> nexusLayer : nexusMatrix )
        {
            /*
             * for each necus in the layer, check the other nexuses in the same
             * layer
             */
            for ( ArgumentNode nexus : nexusLayer )
            {
                for ( ArgumentNode compareNexus : nexusLayer )
                {
                    /*
                     * avoid comparingthe dimensions of a pane to itself
                     */
                    if (  ! nexus.equals( compareNexus ) )
                    {
                        // get the overlap between the nodes
                        double overlap = detectNexusOverlap( nexus, compareNexus );
                        if ( overlap > 0 )
                        {
                            // find linking Node
                            ArgumentNode linkingNode = findLinkingNode( nexus, compareNexus );
                            if ( linkingNode instanceof PremiseNexusNode )
                            {
                                System.out.println( "premise nexus node " );
                                premiseNexusCollision( ( PremiseNexusNode ) linkingNode,  ( int ) overlap / 5 );
                            } 
                            else
                            {
                                System.out.println( "other " );
                                otherCollision( linkingNode, nexus, compareNexus, overlap / 5 );
                            }
                            // note that an adjustment was made
                            adjustmentMade = true;
                        }
                    }
                }
            }
        }
    }
    
    /**
     * Method checks the nexus nodes of the argument tree. If there is overlap
     * between pane nodes on the same level, the youngest common ancestor of the
     * colliding nodes is found and the tree structure is adjusted to create the
     * necessary space
     *
     * @return boolean True if any adjustments are made
     */
    public void nexusMatrixAdjustment( double overlap )
    {
        boolean adjustmentMade = false;
        for ( List<ArgumentNode> nexusLayer : nexusMatrix )
        {
            /*
             * for each necus in the layer, check the other nexuses in the same
             * layer
             */
            for ( ArgumentNode nexus : nexusLayer )
            {
                for ( ArgumentNode compareNexus : nexusLayer )
                {
                    /*
                     * avoid comparingthe dimensions of a pane to itself
                     */
                    if (  ! nexus.equals( compareNexus ) )
                    {
                        // get the overlap between the nodes
                        if ( true )
                        {
                            // find linking Node
                            ArgumentNode linkingNode = findLinkingNode( nexus, compareNexus );
                            if ( linkingNode instanceof PremiseNexusNode )
                            {
                                premiseNexusCollision( ( PremiseNexusNode ) linkingNode,  ( int ) overlap );
                            } 
                            else
                            {
                                otherCollision( linkingNode, nexus, compareNexus, overlap );
                            }
                            // note that an adjustment was made
                            adjustmentMade = true;
                        }
                    }
                }
            }
        }
    }    

    /**
     * helper method calculates how much space needs to be made between two
     * argument panes on the same layer. A minimum of PREMISE_WIDTH is required
     * between nexuses
     *
     * @param current ArgumentNode
     * @param compare ArgumentNode
     *
     * @return double
     */
    private double detectPaneOverlap( ArgumentNode targetPane, ArgumentNode comparePane )
    {
        double targetMinX  = targetPane.getView().getBoundsInParent().getMinX();
        double targetMaxX  = targetPane.getView().getBoundsInParent().getMaxX();

        double compareMinX = comparePane.getView().getBoundsInParent().getMinX();
        double compareMaxX = comparePane.getView().getBoundsInParent().getMaxX();

        if ( ( compareMinX < ( targetMaxX + PADDING )
                && compareMinX > ( targetMinX - PADDING ) )
                || ( compareMaxX > ( targetMinX - PADDING )
                && compareMaxX < ( targetMinX + PADDING ) ) )
        {
            return Math.min( Math.abs( compareMaxX - ( targetMinX + PADDING ) ),
                             Math.abs( compareMinX - ( targetMaxX + PADDING ) ) );
        }
        
        return -1;
    }

    /**
     * helper method calculates how much space needs to be made between two
     * nexuses.
     *
     * @param targetNexus ArgumentNode
     * @param compareNexus ArgumentNode
     *
     * @return
     */
    private double detectNexusOverlap( ArgumentNode targetNexus, ArgumentNode compareNexus )
    {
        double targetMinX  = targetNexus.getView().getBoundsInParent().getMinX();
        double targetMaxX  = targetNexus.getView().getBoundsInParent().getMaxX();
        double compareMinX = compareNexus.getView().getBoundsInParent().getMinX();
        double compareMaxX = compareNexus .getView() .getBoundsInParent().getMaxX();

        if ( ( compareMinX < ( targetMaxX + PADDING + PREMISE_WIDTH )
                && compareMinX > ( targetMinX - PADDING + PREMISE_WIDTH ) )
                || ( compareMaxX > ( targetMinX - PADDING + PREMISE_WIDTH )
                && compareMaxX < ( targetMaxX + PADDING + PREMISE_WIDTH ) ) )
        {
            return Math.min( Math.abs( compareMaxX - ( targetMinX + PADDING + PREMISE_WIDTH ) ),
                             Math.abs( compareMinX - ( targetMaxX + PADDING + PREMISE_WIDTH ) ) );
        }
        return -1;
    }

    /**
     * Re-routes collision adjustment to correct method depending on the type of
     * nodes colliding
     *
     * @param linkingNode ArgumentNode common ancestor node
     * @param nexus ArgumentNode
     * @param compareNexus ArgumentNode
     * @param overlap double overlap between argument nodes
     */
    private void otherCollision( ArgumentNode linkingNode, ArgumentNode nexus, ArgumentNode compareNexus, double overlap )
    {
        for ( ArgumentNode child : linkingNode.getChildren() )
        {
            if ( child instanceof CounterArgumentConnectionNode
                    && ( containsNode( child, nexus )
                    || containsNode( child, compareNexus ) ) )
            {
                counterArgumentConnectionCollision(
                        ( CounterArgumentConnectionNode ) child,
                        overlap
                );
            } else if ( child instanceof CQConnectionNode
                    && ( containsNode( child, nexus )
                    || containsNode( child, compareNexus ) ) )
            {
                cqConnectionCollision(
                        ( CQConnectionNode ) child,
                        overlap
                );
            }
        }

    }

    /**
     * Grows a CQ connector to solve a collision involving a critical question
     * structure
     *
     * @param cqConnector ArgumentNode the connector being grown
     * @param overlap double overlap of collision
     */
    private void cqConnectionCollision( CQConnectionNode cqConnector, double overlap )
    {
        /*
         * grow and move the CQ connection
         */
        cqConnector.addLength( ( int ) overlap );
        translateNode( cqConnector,  - overlap, 0 );
    }

    /**
     * Grows a counter argument connector to solve a collision involving a
     * counter argument structure
     *
     * @param counterArgConnector ArgumentNode the connector being grown
     * @param overlap double overlap of collision
     */
    private void counterArgumentConnectionCollision( CounterArgumentConnectionNode counterArgConnector,
                                                     double overlap )
    {
        /*
         * grow the counter argument connection
         */
        counterArgConnector.addLength( ( int ) overlap );
        /*
         * shift the counter argument structure to align with new length
         */
        for ( ArgumentNode child : counterArgConnector.getChildren() )
        {
            translateNode( child, overlap, 0 );
        }
    }

    /**
     * Grows a ArgumentNode nexus to solve a collision not involving critical
     * questions or counter arguments
     *
     * @param sharedNexus ArgumentNode common ancestor
     * @param overlap double overlap of collision
     */
    private void premiseNexusCollision( PremiseNexusNode sharedNexus, int overlap )
    {
        /*
         * grow and shift the ancestor nexus to accomidate the growth
         */
        int numChildren = sharedNexus.getChildren().size();
        sharedNexus.growWidth( overlap * ( numChildren - 1 ) );
        sharedNexus.getView().setLayoutX( ( int ) ( sharedNexus.getView().getLayoutX()
                                      - ( ( overlap * ( numChildren - 1 ) ) / 2 ) ) );
        /*
         * shift the left and right sub-trees of the ancestor nexus
         */
        shiftRightSidePremises( sharedNexus, ( int ) overlap );
        shiftLeftSidePremises( sharedNexus, ( int ) overlap );
    }

    /**
     * shifts the left children of a nexus
     *
     * @param nexus
     * @param growth
     */
    private void shiftLeftSidePremises( PremiseNexusNode nexus, int growth )
    {
        int numChildren = nexus.getChildren().size();
        int sideCounter = 0;
        for ( int i = 0; i < numChildren / 2; i ++ )
        {
            translateNode( nexus.getChildren().get( i ), - ( ( growth * ( numChildren - 1 ) ) / 2 ) + ( growth * sideCounter ), 0);
            sideCounter ++;
        }
    }

    /**
     * shifts the right side children of a nexus
     *
     * @param nexus
     * @param growth
     */
    private void shiftRightSidePremises( PremiseNexusNode nexus, int growth )
    {
        int numChildren = nexus.getChildren().size();
        int sideCounter = 0;
        for ( int i = numChildren; i > numChildren / 2; i -- )
        {
            translateNode( nexus.getChildren().get( i - 1 ), ( ( growth * ( numChildren - 1 ) ) / 2 ) - ( growth * sideCounter ), 0 );
            sideCounter ++;
        }
    }

    /**
     * Method to find the common ancestor of 2 ArgumentNodes
     *
     * @param a ArgumentNode
     * @param b ArgumentNode
     *
     * @return ArgumentNode common ancestor
     */
    private ArgumentNode findLinkingNode( ArgumentNode a, ArgumentNode b )
    {
        List<ArgumentNode> aAncestryList = new ArrayList<>();
        ArgumentNode youngestLinkingNode = null;
        while ( a != null )
        {
            aAncestryList.add( a );
            a = a.getParent();
        }
        while ( youngestLinkingNode == null && b != null )
        {
            if ( aAncestryList.contains( b ) )
            {
                youngestLinkingNode = b;
            }
            b = b.getParent();
        }

        return youngestLinkingNode;
    }

    private void updateNexusMatrix( ArgumentNode parentPane, ArgumentNode counterIcon, ArgumentNode counterPane )
    {
        ListIterator<List<ArgumentNode>> matrixIt = paneMatrix.listIterator( 0 );
        List<ArgumentNode> targetLayer = null;
        while ( targetLayer == null && matrixIt.hasNext() )
        {
            List<ArgumentNode> inspectedLayer = matrixIt.next();
            for ( ArgumentNode pane : inspectedLayer )
            {
                if ( pane.equals( parentPane ) )
                {
                    targetLayer = inspectedLayer;
                }
            }
        }

        targetLayer.add( counterIcon );

        if (  ! matrixIt.hasNext() )
        {
            List<ArgumentNode> newLayer = new ArrayList<>();
            matrixIt.add( newLayer );
            matrixIt.previous();
        }
        
        targetLayer = matrixIt.next();
        targetLayer.add( counterPane );
    }

    private void updateAllCollisionMatricesOnDetach( ArgumentViewTree newArgTree )
    {
        updateMatrixOnDetach( newArgTree, paneMatrix, newArgTree.getPaneMatrix() );
        updateMatrixOnDetach( newArgTree, nexusMatrix, newArgTree.getNexusMatrix() );
    }

    private void removeSubTreeFromMatrices( ArgumentNode target )
    {
        removeSubTreeFromMatrix( target, paneMatrix );
        removeSubTreeFromMatrix( target, nexusMatrix );
    }

    private void removeSubTreeFromMatrix( ArgumentNode target, List<List<ArgumentNode>> matrix )
    {
        ListIterator<List<ArgumentNode>> layerIT = matrix.listIterator();
        while ( layerIT.hasNext() )
        {
            List<ArgumentNode> currentLayer = layerIT.next();
            ListIterator<ArgumentNode> nodeIT = currentLayer.listIterator();
            while ( nodeIT.hasNext() )
            {
                ArgumentNode currentNode = nodeIT.next();
                if ( containsNode( target, currentNode ) )
                {
                    nodeIT.remove();
                    if ( currentLayer.isEmpty() )
                    {
                        layerIT.remove();
                    }
                }
            }
        }
    }

    private void printMatrix( List<List<ArgumentNode>> matrix )
    {
        for ( int i = 0; i < matrix.size(); i ++ )
        {
            System.out.print( "Layer " + i + ": " );
            for ( int j = 0; j < matrix.get( i ).size(); j ++ )
            {
                System.out.print( ":" + matrix.get( i ).get( j ) + ": " );
            }
            System.out.println( "" );
        }
    }
    
    public List<PremiseConnectionNode> getPremiseConnectionNodes()
    {
        return this.premiseConnectionNodes;
    }

    private List<ArgumentNode> findMatrixLayer( ArgumentNode target, List<List<ArgumentNode>> matrix )
    {
        List<ArgumentNode> targetLayer = null;
        for ( int i = 0; targetLayer == null && i < matrix.size(); i ++ )
        {
            for ( int j = 0; targetLayer == null && j < matrix.get( i ).size(); j ++ )
            {
                if ( matrix.get( i ).get( j ).equals( target ) )
                {
                    targetLayer = matrix.get( i );
                }
            }
        }
        if ( targetLayer != null )
        {
            return targetLayer;
        } 
        else
        {
            targetLayer = new ArrayList<>();
            matrix.add( targetLayer );
            return targetLayer;
        }
    }

    private ArgumentNode findNextNexus( ArgumentNode node )
    {
        Queue<ArgumentNode> queue = new LinkedList<>();
        ArgumentNode resultNode = null;
        queue.add( node );
        while ( resultNode == null &&  ! queue.isEmpty() )
        {
            ArgumentNode currentNode = queue.remove();
            if ( currentNode instanceof PremiseNexusNode )
            {
                resultNode = currentNode;
            } else
            {
                queue.addAll( currentNode.getChildren() );
            }
        }
        return resultNode;
    }
    
    @Override
    public String toString()
    {
        StringBuilder s = new StringBuilder();

        List<ArgumentNode> children = this.root.getChildren();

        for ( ArgumentNode am : children )
        {
            s.append( am ).append( "\n" );
        }
        return s.toString();
    }
    
    private String repeat( String s, int n )
    {
        if( n <= 0 || s.isEmpty() )
        {
            return null;
        }
        else
        {
            StringBuilder str = new StringBuilder();
            
            for( int i = 0; i < n; i++ )
            {
                str.append( s );
            }
            return str.toString();
        }
    }
}

class ArgNodeDepthPair
{
    protected ArgumentNode n;
    protected int          depth;
    
    public ArgNodeDepthPair( ArgumentNode n, int depth )
    {
        this.n     = n;
        this.depth = depth;
    }
}
